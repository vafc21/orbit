<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Orbit - Student Hub Prototype</title>
    <link rel="icon" href="assets/orbit-circle-logo.ico" />
    <style>
      :root {
        color-scheme: light;
        --bg: #f5f2ec;
        --bg-alt: #f1f4f8;
        --surface: #ffffff;
        --surface-2: #f2f5f9;
        --surface-3: #e8eef6;
        --border: rgba(15, 23, 42, 0.1);
        --text: #0f172a;
        --muted: #586176;
        --accent: #16b79a;
        --accent-2: #f4b860;
        --accent-3: #2c7be5;
        --danger: #e15454;
        --success: #2fbf8b;
        --shadow: 0 24px 60px rgba(15, 23, 42, 0.12);
        --shadow-soft: 0 16px 40px rgba(15, 23, 42, 0.08);
        --radius-lg: 20px;
        --radius-md: 14px;
        --radius-sm: 10px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Avenir Next", "Optima", "Trebuchet MS", sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
        line-height: 1.5;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image:
          radial-gradient(circle at 12% 18%, rgba(22, 183, 154, 0.18), transparent 55%),
          radial-gradient(circle at 88% 14%, rgba(44, 123, 229, 0.16), transparent 52%),
          radial-gradient(circle at 20% 82%, rgba(244, 184, 96, 0.18), transparent 60%),
          linear-gradient(160deg, rgba(255, 255, 255, 0.92) 0%, rgba(245, 242, 236, 0.96) 45%, rgba(235, 244, 247, 0.96) 100%);
        pointer-events: none;
        z-index: 0;
      }

      body.midnight::before {
        background-image:
          radial-gradient(circle at 15% 20%, rgba(22, 183, 154, 0.12), transparent 55%),
          radial-gradient(circle at 85% 10%, rgba(44, 123, 229, 0.12), transparent 50%),
          radial-gradient(circle at 20% 80%, rgba(244, 184, 96, 0.12), transparent 60%),
          linear-gradient(160deg, rgba(10, 14, 22, 0.92) 0%, rgba(11, 17, 26, 0.96) 45%, rgba(9, 15, 24, 0.96) 100%);
      }

      body.midnight {
        color-scheme: dark;
        --bg: #0b1118;
        --bg-alt: #0f1826;
        --surface: #151f30;
        --surface-2: #1c2738;
        --surface-3: #243146;
        --border: rgba(255, 255, 255, 0.08);
        --text: #f5f7fb;
        --muted: #a0abc0;
        --shadow: 0 22px 50px rgba(0, 0, 0, 0.45);
        --shadow-soft: 0 18px 36px rgba(0, 0, 0, 0.35);
      }

      body.reduce-motion * {
        animation: none !important;
        transition: none !important;
      }

      .app {
        position: relative;
        z-index: 1;
        display: grid;
        grid-template-columns: 1fr;
        min-height: 100vh;
      }

      .sidebar {
        display: none;
        padding: 24px;
        background: var(--bg-alt);
        border-right: 1px solid var(--border);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 28px;
      }

      .brand-mark {
        width: 44px;
        height: 44px;
        border-radius: 14px;
        background: linear-gradient(140deg, var(--accent), var(--accent-3));
        display: grid;
        place-items: center;
        font-weight: 700;
        color: #0b0f16;
        letter-spacing: 0.04em;
      }

      .brand h1 {
        margin: 0;
        font-size: 1.2rem;
      }

      .brand p {
        margin: 2px 0 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .nav-list {
        display: grid;
        gap: 10px;
      }

      .nav-button {
        background: transparent;
        border: 1px solid transparent;
        color: var(--muted);
        padding: 12px 14px;
        border-radius: 12px;
        text-align: left;
        font-weight: 600;
        cursor: pointer;
        touch-action: manipulation;
        transition: 0.2s ease;
      }

      .nav-button.active {
        background: rgba(22, 183, 154, 0.16);
        color: var(--text);
        border-color: rgba(22, 183, 154, 0.4);
      }

      .sidebar-footer {
        margin-top: 24px;
        padding: 14px;
        border-radius: var(--radius-md);
        background: var(--surface);
        border: 1px solid var(--border);
        box-shadow: var(--shadow-soft);
      }

      .sidebar-footer p {
        margin: 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .sidebar-footer strong {
        color: var(--text);
      }

      .status-chip {
        display: inline-flex;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(22, 183, 154, 0.16);
        color: var(--text);
        font-size: 0.78rem;
        font-weight: 600;
        margin-bottom: 10px;
      }

      .content {
        padding: 20px 20px 100px;
        display: grid;
        gap: 24px;
      }

      .mobile-brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .mobile-brand .brand-mark {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        font-size: 0.85rem;
      }

      .mobile-brand strong {
        display: block;
        font-size: 1rem;
      }

      .mobile-brand small {
        display: block;
        color: var(--muted);
        font-size: 0.75rem;
        margin-top: 2px;
      }

      .topbar {
        display: flex;
        flex-direction: column;
        gap: 12px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 16px 18px;
        box-shadow: var(--shadow-soft);
      }

      .headline {
        display: grid;
        gap: 4px;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.3em;
        font-size: 0.65rem;
        color: var(--muted);
      }

      .topbar h2 {
        margin: 0;
        font-size: 1.6rem;
      }

      .topbar p {
        margin: 4px 0 0;
        color: var(--muted);
      }

      .top-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .user-chip {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 6px 12px 6px 6px;
      }

      .user-chip strong {
        display: block;
        font-size: 0.9rem;
      }

      .user-chip small {
        display: block;
        font-size: 0.7rem;
        color: var(--muted);
      }

      .avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-weight: 700;
        font-size: 0.75rem;
        color: #fff;
        background: linear-gradient(135deg, var(--accent), var(--accent-3));
      }

      .avatar.has-image {
        padding: 0;
        background: transparent;
        overflow: hidden;
      }

      .avatar.has-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
      }

      .link-button {
        background: none;
        border: none;
        color: var(--text);
        cursor: pointer;
        padding: 0;
        font: inherit;
        text-align: left;
        text-decoration: none;
      }

      .link-button:hover {
        text-decoration: underline;
      }

      .pill {
        padding: 8px 12px;
        border-radius: 999px;
        background: rgba(244, 184, 96, 0.25);
        font-weight: 600;
        font-size: 0.85rem;
      }

      .ghost-button,
      .primary-button {
        border-radius: 12px;
        padding: 10px 14px;
        border: 1px solid transparent;
        font-weight: 600;
        cursor: pointer;
        transition: 0.2s ease;
      }

      .primary-button {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 10px 24px rgba(22, 183, 154, 0.25);
      }

      .ghost-button {
        background: transparent;
        border-color: var(--border);
        color: var(--text);
      }

      .ghost-button:hover,
      .primary-button:hover {
        transform: translateY(-1px);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
      }

      .page {
        display: none;
        animation: floatIn 0.4s ease;
      }

      .page.active {
        display: grid;
        gap: 20px;
      }

      @keyframes floatIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes countdown-tick {
        0% {
          transform: scale(1);
          text-shadow: none;
        }
        40% {
          transform: scale(1.08);
          text-shadow: 0 10px 22px rgba(22, 183, 154, 0.3);
        }
        100% {
          transform: scale(1);
          text-shadow: none;
        }
      }

      .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 18px;
        box-shadow: var(--shadow-soft);
      }

      .card h3 {
        margin: 0 0 10px;
        font-size: 1.1rem;
      }

      .muted {
        color: var(--muted);
      }

      .segmented {
        display: inline-flex;
        gap: 6px;
        background: var(--surface-2);
        border-radius: 999px;
        padding: 6px;
        border: 1px solid var(--border);
      }

      .segmented button {
        background: transparent;
        border: none;
        color: var(--muted);
        padding: 8px 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }

      .segmented button.active {
        background: rgba(45, 226, 166, 0.2);
        color: var(--text);
      }

      .segmented button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .schedule-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
      }

      .schedule-select {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 8px 12px;
        color: var(--text);
        font-family: inherit;
        font-weight: 600;
      }

      .schedule-select:disabled {
        opacity: 0.6;
      }

      .schedule-layout {
        display: grid;
        gap: 16px;
      }

      .schedule-side {
        display: grid;
        gap: 16px;
      }

      .schedule-grid {
        display: grid;
        gap: 12px;
      }

      .schedule-day {
        background: var(--surface);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border);
        padding: 12px;
        display: grid;
        gap: 10px;
      }

      .schedule-day h4 {
        margin: 0;
        font-size: 1rem;
      }

      .class-item {
        background: var(--surface-2);
        border: 1px solid transparent;
        border-left: 4px solid var(--accent-color);
        padding: 10px;
        border-radius: 12px;
        color: var(--text);
        text-align: left;
        cursor: pointer;
        transition: 0.2s ease;
      }

      .class-item small {
        display: block;
        color: var(--muted);
        margin-top: 4px;
      }

      .class-item:hover,
      .class-item.active {
        border-color: rgba(15, 23, 42, 0.08);
        background: var(--surface-3);
      }

      .details-grid {
        display: grid;
        gap: 10px;
      }

      .details-grid div {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        color: var(--muted);
      }

      .details-grid strong {
        color: var(--text);
      }

      .countdown-hero {
        display: flex;
        justify-content: center;
      }

      .countdown-card {
        width: min(720px, 100%);
        text-align: center;
        padding: 28px 22px 24px;
        position: relative;
        overflow: hidden;
        background:
          radial-gradient(circle at top, rgba(22, 183, 154, 0.18), transparent 55%),
          linear-gradient(135deg, rgba(244, 184, 96, 0.14), rgba(44, 123, 229, 0.12));
        border: 1px solid rgba(15, 23, 42, 0.08);
      }

      body.midnight .countdown-card {
        background:
          radial-gradient(circle at top, rgba(22, 183, 154, 0.2), transparent 60%),
          linear-gradient(135deg, rgba(44, 123, 229, 0.18), rgba(15, 23, 42, 0.55));
        border-color: rgba(255, 255, 255, 0.08);
      }

      .countdown-card h3 {
        font-size: 1.2rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .countdown-time {
        font-size: clamp(2.6rem, 4vw, 3.6rem);
        font-weight: 750;
        margin: 12px 0 6px;
        letter-spacing: 0.08em;
      }

      .countdown-time.tick {
        animation: countdown-tick 0.45s cubic-bezier(0.2, 0.8, 0.2, 1);
      }

      .countdown-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        color: var(--muted);
        font-size: 0.9rem;
        justify-content: center;
      }

      .schedule-form {
        display: grid;
        gap: 10px;
      }

      .schedule-form input,
      .schedule-form select {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
      }

      .schedule-setup {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 24px;
        background: rgba(11, 15, 22, 0.55);
        z-index: 50;
      }

      .schedule-setup.active {
        display: flex;
      }

      .setup-card {
        width: min(960px, 100%);
        max-height: 92vh;
        overflow: auto;
        display: grid;
        gap: 18px;
      }

      .setup-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .setup-step {
        font-size: 0.85rem;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(22, 183, 154, 0.14);
        font-weight: 600;
      }

      .setup-options {
        display: grid;
        gap: 12px;
      }

      .setup-option {
        text-align: left;
        background: var(--surface-2);
        border: 1px solid transparent;
        border-radius: var(--radius-md);
        padding: 14px;
        color: var(--text);
        display: grid;
        gap: 6px;
        cursor: pointer;
        transition: 0.2s ease;
      }

      .setup-option span {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .setup-option.active {
        border-color: rgba(22, 183, 154, 0.6);
        background: rgba(22, 183, 154, 0.12);
      }

      .setup-details {
        display: grid;
        gap: 12px;
      }

      .setup-details[hidden] {
        display: none;
      }

      .setup-meta {
        display: grid;
        gap: 8px;
      }

      .setup-field {
        display: grid;
        gap: 6px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .setup-field input {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        color: var(--text);
        font-family: inherit;
      }

      .setup-note {
        background: var(--surface-2);
        border-radius: 12px;
        padding: 12px 14px;
        border: 1px solid var(--border);
        color: var(--muted);
        font-size: 0.9rem;
      }

      .setup-forms {
        display: grid;
        gap: 12px;
      }

      .setup-day {
        background: var(--surface-2);
        border-radius: 16px;
        padding: 14px;
        border: 1px solid var(--border);
        display: grid;
        gap: 10px;
      }

      .setup-day h4 {
        margin: 0;
        font-size: 0.95rem;
      }

      .setup-rows {
        display: grid;
        gap: 10px;
      }

      .setup-row {
        display: grid;
        gap: 8px;
      }

      .setup-row input {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        color: var(--text);
        font-family: inherit;
      }

      .setup-row.error input {
        border-color: rgba(225, 84, 84, 0.6);
      }

      .setup-row button {
        justify-self: start;
      }

      .setup-add {
        align-self: start;
      }

      .setup-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .setup-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .setup-error {
        min-height: 18px;
        color: var(--danger);
        font-size: 0.9rem;
      }

      @media (min-width: 900px) {
        .setup-options {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }

        .setup-row {
          grid-template-columns: minmax(180px, 1.4fr) repeat(2, 120px) minmax(120px, 1fr) auto;
          align-items: center;
        }

        .setup-row button {
          justify-self: end;
        }
      }

      .tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(44, 123, 229, 0.16);
        font-size: 0.8rem;
        font-weight: 600;
      }

      .chat-layout {
        display: grid;
        gap: 16px;
      }

      .chat-mode-toggle {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0 4px;
      }

      .chat-mode-toggle button {
        background: var(--surface-2);
        border: 1px solid transparent;
        color: var(--muted);
        padding: 8px 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      }

      .chat-mode-toggle button.active {
        color: var(--text);
        border-color: rgba(44, 123, 229, 0.5);
        background: rgba(44, 123, 229, 0.15);
      }

      .chat-mode-toggle button:hover {
        transform: translateY(-1px);
      }

      .chat-class-list {
        display: grid;
        gap: 10px;
        max-height: 320px;
        overflow-y: auto;
        padding-right: 6px;
      }

      .chat-class-list button {
        width: 100%;
        background: var(--surface-2);
        border: 1px solid transparent;
        border-radius: 14px;
        padding: 12px;
        color: var(--text);
        text-align: left;
        cursor: pointer;
      }

      .chat-class-list button.active {
        border-color: rgba(44, 123, 229, 0.5);
        background: rgba(44, 123, 229, 0.12);
      }

      .chat-group-form {
        display: grid;
        gap: 8px;
        margin-top: 14px;
      }

      .chat-group-form input {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
      }

      .chat-thread {
        display: grid;
        gap: 12px;
      }

      .chat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .chat-messages {
        max-height: 320px;
        overflow-y: auto;
        display: grid;
        gap: 10px;
        padding-right: 6px;
      }

      .message {
        background: var(--surface-2);
        border-radius: 14px;
        padding: 10px 12px;
        width: fit-content;
        max-width: 80%;
        border: 1px solid var(--border);
      }

      .message.mine {
        margin-left: auto;
        background: rgba(22, 183, 154, 0.2);
        border-color: rgba(22, 183, 154, 0.35);
      }

      .message small {
        display: block;
        color: var(--muted);
        margin-top: 4px;
        font-size: 0.75rem;
      }

      .chat-input {
        display: flex;
        gap: 10px;
      }

      .chat-input input {
        flex: 1;
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
      }

      .chat-input button {
        background: var(--accent);
        border: none;
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 600;
        cursor: pointer;
        color: #fff;
      }

      .study-stage {
        display: none;
        gap: 20px;
      }

      .study-stage.active {
        display: grid;
        animation: stageIn 0.45s ease;
      }

      .study-workspace {
        display: grid;
        gap: 20px;
      }

      .study-workspace-view {
        display: none;
        gap: 20px;
      }

      .study-workspace-view.active {
        display: grid;
      }

      .study-workspace-view[data-study-view="study"] {
        min-height: 60vh;
      }

      .study-hero {
        display: grid;
        gap: 12px;
      }

      .study-hero-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .study-selection-grid {
        display: grid;
        gap: 16px;
      }

      .study-select-list {
        display: grid;
        gap: 12px;
      }

      .study-select-card {
        border: 1px solid var(--border);
        background: var(--surface-2);
        border-radius: 16px;
        padding: 14px;
        text-align: left;
        display: grid;
        gap: 8px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        animation: riseIn 0.35s ease both;
      }

      .study-select-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-soft);
      }

      .study-select-card.active {
        border-color: rgba(22, 183, 154, 0.5);
        box-shadow: var(--shadow-soft);
      }

      .study-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .study-chip {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .study-chip.public {
        background: rgba(22, 183, 154, 0.2);
        color: var(--text);
      }

      .study-chip.private {
        background: rgba(148, 163, 184, 0.2);
        color: var(--muted);
      }

      .study-modes {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .study-modes button {
        background: var(--surface-2);
        border: 1px solid transparent;
        color: var(--muted);
        padding: 8px 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      }

      .study-modes button.active {
        color: var(--text);
        border-color: rgba(244, 184, 96, 0.6);
        background: rgba(244, 184, 96, 0.25);
        box-shadow: 0 10px 20px rgba(244, 184, 96, 0.2);
      }

      .study-modes button:hover {
        transform: translateY(-1px);
      }

      .study-set-grid {
        display: grid;
        gap: 16px;
      }

      .study-set-list,
      .study-card-list {
        display: grid;
        gap: 12px;
      }

      .study-set-card,
      .study-card-item {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        display: grid;
        gap: 8px;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        animation: riseIn 0.3s ease both;
      }

      .study-set-card {
        cursor: pointer;
      }

      .study-set-card:hover,
      .study-card-item:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-soft);
      }

      .study-set-card.active {
        border-color: rgba(22, 183, 154, 0.45);
        box-shadow: var(--shadow-soft);
      }

      .study-set-card .actions,
      .study-card-item .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .study-card-meta {
        color: var(--muted);
        font-size: 0.8rem;
      }

      .study-form {
        display: grid;
        gap: 10px;
      }

      .study-form label {
        display: grid;
        gap: 6px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .study-form input,
      .study-form textarea {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
      }

      .study-form textarea {
        min-height: 90px;
        resize: vertical;
      }

      .study-form .toggle-inline {
        align-items: center;
      }

      .study-import-controls {
        display: grid;
        gap: 10px;
      }

      .study-import-status {
        min-height: 18px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .study-import-status.success {
        color: var(--success);
      }

      .study-import-status.error {
        color: var(--danger);
      }

      @media (min-width: 720px) {
        .study-import-controls {
          grid-template-columns: repeat(2, minmax(0, 1fr));
          align-items: end;
        }
      }

      .study-panel-header {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .study-panel-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .study-panel-actions input[type="number"] {
        width: 90px;
      }

      .toggle-inline {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .toggle-inline input {
        accent-color: var(--accent);
      }

      .study-empty {
        border: 1px dashed var(--border);
        border-radius: 12px;
        padding: 12px;
        color: var(--muted);
      }

      .study-panel {
        display: none;
      }

      .study-panel.active {
        display: grid;
        gap: 14px;
        animation: panelIn 0.4s ease;
      }

      .flashcard {
        position: relative;
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 24px;
        min-height: 160px;
        cursor: pointer;
        perspective: 1000px;
        display: grid;
        place-items: center;
        text-align: center;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .flashcard:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-soft);
      }

      .flashcard-inner {
        position: relative;
        width: 100%;
        height: 100%;
        transition: transform 0.4s ease;
        transform-style: preserve-3d;
      }

      .flashcard.flipped .flashcard-inner {
        transform: rotateY(180deg);
      }

      .flashcard-face {
        backface-visibility: hidden;
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-size: 1.2rem;
        padding: 12px;
      }

      .flashcard-back {
        transform: rotateY(180deg);
        color: var(--accent-3);
      }

      .flashcard-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .flashcard-controls button {
        background: var(--surface-3);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
      }

      .matching-board {
        display: grid;
        gap: 14px;
      }

      .matching-columns {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .matching-list {
        display: grid;
        gap: 8px;
      }

      .matching-item {
        border-radius: 12px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        color: var(--text);
        cursor: pointer;
        transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      }

      .matching-item:hover {
        transform: translateY(-1px);
      }

      .matching-item.selected {
        border-color: rgba(44, 123, 229, 0.6);
        background: rgba(44, 123, 229, 0.18);
      }

      .matching-item.matched {
        border-color: rgba(22, 183, 154, 0.6);
        background: rgba(22, 183, 154, 0.18);
        color: var(--text);
      }

      .quiz-card {
        display: grid;
        gap: 12px;
      }

      .quiz-options {
        display: grid;
        gap: 8px;
      }

      .quiz-options button {
        border-radius: 12px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        color: var(--text);
        cursor: pointer;
        text-align: left;
        transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      }

      .quiz-options button:hover {
        transform: translateY(-1px);
      }

      .quiz-options button.correct {
        border-color: rgba(22, 183, 154, 0.6);
        background: rgba(22, 183, 154, 0.2);
      }

      .quiz-options button.incorrect {
        border-color: rgba(255, 107, 107, 0.6);
        background: rgba(255, 107, 107, 0.2);
      }

      .todo-layout {
        display: grid;
        gap: 16px;
      }

      .todo-form {
        display: grid;
        gap: 12px;
      }

      .todo-form input,
      .todo-form select,
      .todo-form textarea {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
      }

      .todo-form textarea {
        min-height: 80px;
        resize: vertical;
      }

      .todo-list {
        display: grid;
        gap: 10px;
      }

      .todo-item {
        border-radius: 14px;
        padding: 12px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        display: grid;
        gap: 8px;
      }

      .todo-item.overdue {
        border-color: rgba(255, 107, 107, 0.6);
      }

      .todo-item.today {
        border-color: rgba(255, 179, 71, 0.6);
      }

      .todo-item.upcoming {
        border-color: rgba(255, 179, 71, 0.6);
      }

      .todo-item.completed {
        opacity: 0.6;
        text-decoration: line-through;
      }

      .todo-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .todo-actions {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .todo-actions button {
        border-radius: 10px;
        padding: 8px 12px;
        border: 1px solid var(--border);
        background: var(--surface-3);
        color: var(--text);
        cursor: pointer;
      }

      .filter-row {
        display: grid;
        gap: 10px;
      }

      .profile-grid {
        display: grid;
        gap: 16px;
      }

      .profile-card {
        display: grid;
        gap: 10px;
      }

      .profile-form {
        display: grid;
        gap: 12px;
      }

      .profile-actions {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .profile-form textarea {
        min-height: 110px;
        resize: vertical;
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
      }

      .profile-form input[type="file"] {
        color: var(--muted);
      }

      .profile-avatar-preview {
        width: 96px;
        height: 96px;
        border-radius: 18px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        display: grid;
        place-items: center;
        overflow: hidden;
        font-weight: 700;
        color: var(--muted);
      }

      .profile-avatar-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .friend-list {
        display: grid;
        gap: 10px;
      }

      .friends-layout {
        display: grid;
        gap: 16px;
      }

      .friends-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .friends-search {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .friends-search input {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-family: inherit;
        min-width: 200px;
      }

      .friends-schedule-header {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .friends-schedule-actions label {
        display: grid;
        gap: 6px;
        font-size: 0.85rem;
      }

      .friends-schedule-actions select {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 8px 10px;
        color: var(--text);
        font-family: inherit;
      }

      .friend-requests {
        display: grid;
        gap: 10px;
        margin-top: 14px;
      }

      .friend-requests h4 {
        margin: 6px 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .friend-item {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .friend-item.active {
        border-color: rgba(22, 183, 154, 0.45);
        box-shadow: var(--shadow-soft);
      }

      .friend-item-actions {
        display: flex;
        gap: 6px;
      }

      .friend-item span {
        font-weight: 600;
      }

      .friend-item button {
        background: var(--surface-3);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 10px;
        padding: 6px 10px;
        cursor: pointer;
      }

      .settings-list {
        display: grid;
        gap: 10px;
      }

      .toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: var(--surface-2);
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .toggle input {
        appearance: none;
        width: 44px;
        height: 24px;
        background: rgba(15, 23, 42, 0.08);
        border-radius: 999px;
        position: relative;
        outline: none;
        cursor: pointer;
      }

      .toggle input::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        transition: 0.2s ease;
      }

      .toggle input:checked {
        background: rgba(45, 226, 166, 0.4);
      }

      .toggle input:checked::after {
        transform: translateX(20px);
      }

      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.95);
        border-top: 1px solid var(--border);
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        padding: 8px 10px calc(14px + env(safe-area-inset-bottom, 0px));
        z-index: 10;
        box-shadow: 0 -12px 30px rgba(15, 23, 42, 0.08);
      }

      .bottom-nav button {
        background: transparent;
        border: none;
        color: var(--muted);
        font-weight: 600;
        padding: 8px;
        cursor: pointer;
        touch-action: manipulation;
      }

      .bottom-nav button.active {
        color: var(--text);
      }

      .feedback-widget {
        position: fixed;
        right: 20px;
        bottom: calc(20px + env(safe-area-inset-bottom, 0px) + 70px);
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 12px;
        z-index: 20;
      }

      .feedback-toggle {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 1px solid var(--border);
        background: var(--surface);
        box-shadow: var(--shadow-soft);
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .feedback-toggle:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .feedback-toggle img {
        width: 32px;
        height: 32px;
        object-fit: contain;
      }

      .feedback-widget.open .feedback-toggle {
        box-shadow: 0 0 0 4px rgba(22, 183, 154, 0.2), var(--shadow-soft);
      }

      .feedback-panel {
        width: min(320px, calc(100vw - 32px));
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 16px;
        box-shadow: var(--shadow);
        transform-origin: bottom right;
        transform: translateY(12px) scale(0.96);
        opacity: 0;
        pointer-events: none;
        transition: 0.2s ease;
      }

      .feedback-widget.open .feedback-panel {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .feedback-panel h4 {
        margin: 0 0 6px;
      }

      .feedback-panel textarea {
        width: 100%;
        min-height: 96px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        color: var(--text);
        font-family: inherit;
        resize: vertical;
      }

      .feedback-panel textarea:focus {
        outline: 2px solid rgba(22, 183, 154, 0.4);
        border-color: transparent;
      }

      .feedback-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 12px;
      }

      .feedback-status {
        margin: 10px 0 0;
        font-size: 0.85rem;
        color: var(--muted);
        min-height: 1.1em;
      }

      .feedback-status.error {
        color: var(--danger);
      }

      .feedback-status.success {
        color: var(--success);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      @keyframes stageIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes riseIn {
        from {
          opacity: 0;
          transform: translateY(8px) scale(0.98);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      @keyframes panelIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      body.midnight .class-item:hover,
      body.midnight .class-item.active {
        border-color: rgba(255, 255, 255, 0.08);
      }

      body.midnight .toggle input {
        background: rgba(255, 255, 255, 0.08);
      }

      body.midnight .bottom-nav {
        background: rgba(16, 23, 37, 0.96);
        box-shadow: 0 -12px 30px rgba(0, 0, 0, 0.35);
      }

      body.midnight .feedback-toggle img {
        filter: brightness(0) invert(1);
      }

      @media (min-width: 900px) {
        .app {
          grid-template-columns: 260px 1fr;
        }

        .sidebar {
          display: block;
          min-height: 100vh;
        }

        .content {
          padding: 28px 32px 40px;
        }

        .mobile-brand {
          display: none;
        }

        .topbar {
          flex-direction: row;
          align-items: center;
          justify-content: space-between;
        }

        .schedule-layout {
          grid-template-columns: 2fr 1fr;
        }

        .schedule-grid {
          grid-template-columns: repeat(5, minmax(160px, 1fr));
        }

        .chat-layout {
          grid-template-columns: 240px 1fr;
        }

        .chat-class-list {
          flex-direction: column;
          overflow: visible;
        }

        .friends-layout {
          grid-template-columns: 1.1fr 1.4fr;
          align-items: start;
        }

        .study-set-grid {
          grid-template-columns: 1.2fr 1fr;
          align-items: start;
        }

        .study-selection-grid {
          grid-template-columns: 1.1fr 0.9fr;
        }

        .study-panel-header {
          flex-direction: row;
          align-items: center;
          justify-content: space-between;
        }

        .matching-columns {
          grid-template-columns: 1fr 1fr;
        }

        .filter-row {
          grid-template-columns: repeat(3, 1fr);
        }

        .bottom-nav {
          display: none;
        }

        .feedback-widget {
          bottom: 28px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="sidebar">
        <div class="brand">
          <div class="brand-mark">OR</div>
          <div>
            <h1>Orbit</h1>
            <p>All-in-one student hub</p>
          </div>
        </div>
        <nav class="nav-list">
          <button class="nav-button active" data-page-target="schedule">Schedule</button>
          <button class="nav-button" data-page-target="chat">Chat</button>
          <button class="nav-button" data-page-target="friends">Friends</button>
          <button class="nav-button" data-page-target="study">Study</button>
          <button class="nav-button" data-page-target="todo">To-Do</button>
          <button class="nav-button" data-page-target="profile">Profile</button>
        </nav>
        <div class="sidebar-footer">
          <div class="status-chip">Synced · Just now</div>
          <p><strong id="sidebar-name">Jordan Lee</strong> · Schedule ready for the week.</p>
        </div>
      </aside>

      <main class="content">
        <div class="mobile-brand">
          <div class="brand-mark">OR</div>
          <div>
            <strong>Orbit</strong>
            <small id="mobile-user">Signed in</small>
          </div>
        </div>
        <header class="topbar">
          <div class="headline">
            <span class="eyebrow" id="auth-status">Signed in</span>
            <h2 id="page-title">Schedule</h2>
            <p id="page-subtitle">Plan the week, check in with classmates, and stay on top of everything.</p>
          </div>
          <div class="top-actions">
            <div class="pill" id="today-pill">Tuesday · 2 classes left</div>
            <button class="ghost-button" type="button">Share schedule</button>
            <button class="ghost-button" type="button" id="logout-button">Sign out</button>
            <div class="user-chip">
              <div class="avatar" id="user-avatar">JL</div>
              <div>
                <strong id="user-name">Jordan Lee</strong>
                <small id="user-grade">11th grade</small>
              </div>
            </div>
          </div>
        </header>

        <section class="page active" data-page="schedule">
          <div class="countdown-hero">
            <div class="card countdown-card" id="countdown-card">
              <h3>Countdown</h3>
              <p class="muted" id="countdown-status">Loading your next class...</p>
              <div class="countdown-time" id="countdown-time">--:--:--</div>
              <div class="countdown-meta" id="countdown-meta"></div>
            </div>
          </div>
          <div class="card">
            <h3>Weekly schedule</h3>
            <p class="muted">Tap any class block to see who is in it, where to go, and what's next.</p>
            <div class="schedule-controls">
              <div class="segmented" id="schedule-toggle">
                <button class="active" data-schedule-view="my">My schedule</button>
                <button data-schedule-view="classmate">Classmate: <span id="classmate-name">Add a friend</span></button>
              </div>
              <select class="schedule-select" id="classmate-select" aria-label="Choose friend schedule" hidden></select>
            </div>
          </div>

          <div class="schedule-layout">
            <div class="schedule-grid" id="schedule-grid"></div>
            <div class="schedule-side">
              <div class="card" id="class-details">
                <h3>Class details</h3>
                <p class="muted">Select a class block to see details.</p>
                <div class="details-grid" id="class-details-grid"></div>
              </div>
              <div class="card">
                <h3>Add an activity</h3>
                <p class="muted">Add after-class activities, clubs, or personal reminders.</p>
                <form class="schedule-form" id="schedule-form">
                  <select id="schedule-day" required>
                    <option value="Mon">Monday</option>
                    <option value="Tue">Tuesday</option>
                    <option value="Wed">Wednesday</option>
                    <option value="Thu">Thursday</option>
                    <option value="Fri">Friday</option>
                  </select>
                  <input type="text" id="schedule-title" placeholder="Activity title" required />
                  <input type="time" id="schedule-start" required />
                  <input type="time" id="schedule-end" required />
                  <input type="text" id="schedule-location" placeholder="Location (optional)" />
                  <select id="schedule-type">
                    <option value="club">Club</option>
                    <option value="practice">Practice</option>
                    <option value="study">Study</option>
                    <option value="personal">Personal</option>
                  </select>
                  <button class="primary-button" type="submit">Add to schedule</button>
                </form>
              </div>
            </div>
          </div>

          <div class="schedule-setup" id="schedule-setup" aria-hidden="true">
            <div class="card setup-card" role="dialog" aria-modal="true" aria-labelledby="setup-title">
              <div class="setup-header">
                <div>
                  <h3 id="setup-title">Schedule setup</h3>
                  <p class="muted">Choose how your school week repeats, then add your classes.</p>
                </div>
                <span class="setup-step" id="setup-step">Step 1 of 2</span>
              </div>
              <div class="setup-meta">
                <label class="setup-field" for="setup-school">
                  School name
                  <input id="setup-school" type="text" placeholder="Your school" autocomplete="organization" />
                </label>
              </div>
              <div class="setup-options" id="setup-options">
                <button class="setup-option" type="button" data-setup-type="daily">
                  <strong>Every day same schedule</strong>
                  <span>The same class order and times every weekday.</span>
                </button>
                <button class="setup-option" type="button" data-setup-type="ab">
                  <strong>A/B days</strong>
                  <span>Two schedules that alternate across the week, like Mon A and Tue B.</span>
                </button>
                <button class="setup-option" type="button" data-setup-type="block">
                  <strong>Block schedule</strong>
                  <span>Fewer, longer class blocks with different days rotating.</span>
                </button>
              </div>
              <div class="setup-details" id="setup-details" hidden>
                <div class="setup-note" id="setup-note"></div>
                <div class="setup-forms" id="setup-forms"></div>
              </div>
              <div class="setup-footer">
                <div class="setup-error" id="setup-error"></div>
                <div class="setup-actions">
                  <button class="ghost-button" type="button" id="setup-back" hidden>Back</button>
                  <button class="primary-button" type="button" id="setup-save" disabled>Save schedule</button>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section class="page" data-page="chat">
          <div class="card">
            <h3>Chat hub</h3>
            <p class="muted">Move between classes, direct messages, and group chats.</p>
          </div>
          <div class="chat-layout">
            <div class="card">
              <h3>Chat channels</h3>
              <p class="muted">Switch between classes, friends, and groups.</p>
              <div class="chat-mode-toggle" id="chat-mode-toggle">
                <button class="active" type="button" data-chat-mode="classes">Classes</button>
                <button type="button" data-chat-mode="friends">Friends</button>
                <button type="button" data-chat-mode="groups">Groups</button>
              </div>
              <div class="chat-class-list" id="chat-class-list"></div>
              <form class="chat-group-form" id="group-form">
                <input type="text" id="group-name" placeholder="Group name" required />
                <input type="text" id="group-members" placeholder="Add members (comma separated usernames)" />
                <button class="primary-button" type="submit">Create group</button>
              </form>
            </div>
            <div class="card chat-thread">
              <div class="chat-header">
                <div>
                  <h3 id="chat-title">Select a class</h3>
                  <p class="muted" id="chat-subtitle">Open a class thread to start chatting.</p>
                </div>
                <button class="ghost-button" type="button" id="chat-new-group">New group chat</button>
              </div>
              <div class="chat-messages" id="chat-messages"></div>
              <form class="chat-input" id="chat-form">
                <input type="text" id="chat-input" placeholder="Send a message" autocomplete="off" />
                <button type="submit">Send</button>
              </form>
            </div>
          </div>
        </section>

        <section class="page" data-page="friends">
          <div class="card">
            <h3>Friends</h3>
            <p class="muted">Add friends, search, and view their shared schedules.</p>
          </div>
          <div class="friends-layout">
            <div class="card">
              <div class="friends-header">
                <div>
                  <h3>Your friends</h3>
                  <p class="muted">Add friends to chat and compare schedules.</p>
                </div>
                <div class="friends-search">
                  <input id="friend-search" placeholder="Search by name or username" aria-label="Search friends" />
                </div>
              </div>
              <form class="study-form" id="friend-form">
                <label>
                  Add friend
                  <input id="friend-name" placeholder="Add a friend by username" required />
                </label>
                <button class="primary-button" type="submit">Add friend</button>
              </form>
              <div class="friend-list" id="friend-list"></div>
              <div class="friend-requests">
                <h4>Incoming requests</h4>
                <div class="friend-list" id="friend-requests-incoming"></div>
                <h4>Sent requests</h4>
                <div class="friend-list" id="friend-requests-outgoing"></div>
              </div>
            </div>
            <div class="card" id="friend-schedule-card">
              <div class="friends-schedule-header">
                <div>
                  <h3 id="friend-schedule-title">Friend schedule</h3>
                  <p class="muted" id="friend-schedule-subtitle">Select a friend to view their week.</p>
                </div>
                <div class="friends-schedule-actions">
                  <label>
                    <span class="muted">Day</span>
                    <select id="friend-schedule-day">
                      <option value="all">All days</option>
                      <option value="Mon">Monday</option>
                      <option value="Tue">Tuesday</option>
                      <option value="Wed">Wednesday</option>
                      <option value="Thu">Thursday</option>
                      <option value="Fri">Friday</option>
                    </select>
                  </label>
                </div>
              </div>
              <div class="schedule-grid" id="friend-schedule-grid"></div>
            </div>
          </div>
        </section>

        <section class="page" data-page="study" id="study-root">
          <div class="study-stage active" data-study-stage="select">
            <div class="card study-hero">
              <div>
                <h3>Pick a study set</h3>
                <p class="muted">Public sets show up here when someone marks them as shared.</p>
              </div>
              <div class="study-hero-actions">
                <button class="primary-button" type="button" id="study-enter-workspace">Create or edit sets</button>
                <button class="ghost-button" type="button" id="study-continue">Continue last set</button>
              </div>
            </div>
            <div class="study-selection-grid">
              <div class="card">
                <div class="study-panel-header">
                  <div>
                    <h3>Public sets</h3>
                    <p class="muted">Shared by classmates and clubs.</p>
                  </div>
                </div>
                <div class="study-select-list" id="study-public-list"></div>
              </div>
              <div class="card">
                <div class="study-panel-header">
                  <div>
                    <h3>Private sets</h3>
                    <p class="muted">Drafts only you can see.</p>
                  </div>
                </div>
                <div class="study-select-list" id="study-private-list"></div>
              </div>
            </div>
          </div>

          <div class="study-stage" data-study-stage="workspace">
            <div class="study-workspace">
              <div class="card study-workspace-header">
                <div class="study-panel-header">
                  <div>
                    <h3 id="study-workspace-title">Study workspace</h3>
                    <p class="muted" id="study-workspace-subtitle">Choose a set to start studying.</p>
                  </div>
                  <div class="study-panel-actions">
                    <button class="ghost-button" type="button" id="study-edit-toggle">Edit set</button>
                    <button class="ghost-button" type="button" id="study-back-select">Back to selection</button>
                  </div>
                </div>
              </div>

              <div class="study-workspace-view" data-study-view="edit">
                <div class="card">
              <h3>Your study sets</h3>
              <p class="muted">Create sets with your own terms and definitions.</p>
              <div class="study-set-grid">
                <div class="study-set-list" id="study-set-list"></div>
                <form class="study-form" id="study-set-form">
                  <label>
                    Set title
                    <input id="study-set-title" placeholder="Biology Chapter 3" required />
                  </label>
                  <label>
                    Description (optional)
                    <input id="study-set-description" placeholder="Cell structure and functions" />
                  </label>
                  <label class="toggle-inline">
                    <input type="checkbox" id="study-set-public" />
                    <span>Make this set public</span>
                  </label>
                <button class="primary-button" type="submit">Create set</button>
                </form>
              </div>
            </div>

                <div class="card">
              <h3>Cards in this set</h3>
              <p class="muted">Add the terms and definitions you want to study.</p>
              <form class="study-form" id="study-card-form">
                <label>
                  Term
                  <input id="study-card-term" placeholder="Mitochondria" required />
                </label>
                <label>
                  Definition
                  <textarea id="study-card-definition" placeholder="Organelle that produces energy" required></textarea>
                </label>
                <button class="primary-button" type="submit">Add card</button>
              </form>
              <div class="study-card-list" id="study-card-list"></div>
            </div>

                <div class="card">
              <h3>Import cards</h3>
              <p class="muted">Paste one card per line, like: term<TAB>definition.</p>
              <form class="study-form" id="study-import-form">
                <label>
                  Paste list
                  <textarea id="study-import-text" placeholder="Photosynthesis	Process plants use to make energy"></textarea>
                </label>
                <div class="study-import-controls">
                  <label>
                    Delimiter
                    <select id="study-import-delimiter">
                      <option value="tab">Tab</option>
                      <option value="semicolon">Semicolon ;</option>
                      <option value="dash">Dash -</option>
                      <option value="comma">Comma ,</option>
                      <option value="pipe">Pipe |</option>
                      <option value="custom">Custom</option>
                    </select>
                  </label>
                  <label id="study-import-custom-wrap" hidden>
                    Custom delimiter
                    <input id="study-import-custom" placeholder="::" />
                  </label>
                </div>
                <button class="primary-button" type="submit">Import cards</button>
                <div class="study-import-status" id="study-import-status"></div>
              </form>
            </div>
              </div>

              <div class="study-workspace-view active" data-study-view="study">
                <div class="card">
              <h3>Study modes</h3>
              <p class="muted">Pick a mode for the selected set.</p>
              <div class="study-modes" id="study-mode-toggle">
                <button class="active" data-study-mode="flashcards">Flashcards</button>
                <button data-study-mode="learn">Practice</button>
                <button data-study-mode="test">Test</button>
                <button data-study-mode="match">Match</button>
              </div>
            </div>

                <div class="card study-panel active" data-study-panel="flashcards">
              <div class="study-panel-header">
                <div>
                  <h3>Flashcards</h3>
                  <p class="muted" id="flashcard-subtitle">Flip to reveal the definition.</p>
                </div>
                <div class="study-panel-actions">
                  <label class="toggle-inline">
                    <input type="checkbox" id="flashcard-shuffle" />
                    <span>Shuffle</span>
                  </label>
                  <button class="ghost-button" type="button" id="flashcard-star">Star</button>
                </div>
              </div>
              <div class="flashcard" id="flashcard">
                <div class="flashcard-inner">
                  <div class="flashcard-face" id="flashcard-front"></div>
                  <div class="flashcard-face flashcard-back" id="flashcard-back"></div>
                </div>
              </div>
              <div class="flashcard-controls">
                <button id="flashcard-prev">Prev</button>
                <span class="muted" id="flashcard-progress"></span>
                <button id="flashcard-next">Next</button>
              </div>
            </div>

                <div class="card study-panel" data-study-panel="learn">
              <div class="study-panel-header">
                <div>
                  <h3>Practice</h3>
                  <p class="muted" id="practice-subtitle">Answer with multiple choice or a typed response.</p>
                </div>
                <div class="segmented" id="practice-type-toggle">
                  <button class="active" data-practice-type="mixed">Mixed</button>
                  <button data-practice-type="mc">Multiple choice</button>
                  <button data-practice-type="written">Written</button>
                </div>
              </div>
              <div class="quiz-card" id="practice-card"></div>
            </div>

                <div class="card study-panel" data-study-panel="test">
              <div class="study-panel-header">
                <div>
                  <h3>Test</h3>
                  <p class="muted" id="test-subtitle">Choose how many questions to include.</p>
                </div>
                <div class="study-panel-actions">
                  <input type="number" id="test-count" min="1" max="50" value="10" />
                  <button class="primary-button" type="button" id="test-start">Start test</button>
                </div>
              </div>
              <div class="quiz-card" id="test-card"></div>
            </div>

                <div class="card study-panel" data-study-panel="match">
              <div class="study-panel-header">
                <div>
                  <h3>Match</h3>
                  <p class="muted" id="match-status">Match terms with definitions.</p>
                </div>
                <div class="study-panel-actions">
                  <div class="pill" id="match-timer">00:00</div>
                  <button class="ghost-button" type="button" id="match-reset">New game</button>
                </div>
              </div>
              <div class="matching-board">
                <div class="matching-columns">
                  <div class="matching-list" id="match-terms"></div>
                  <div class="matching-list" id="match-definitions"></div>
                </div>
              </div>
            </div>
              </div>
            </div>
          </div>
        </section>

        <section class="page" data-page="todo">
          <div class="card">
            <h3>Homework and to-do</h3>
            <p class="muted">Assignments stay tied to classes with due dates and quick completion.</p>
          </div>
          <div class="todo-layout">
            <div class="card">
              <h3>Add assignment</h3>
              <form class="todo-form" id="todo-form">
                <select id="todo-class" required></select>
                <input type="text" id="todo-title" placeholder="Assignment title" required />
                <input type="date" id="todo-due" />
                <textarea id="todo-notes" placeholder="Notes"></textarea>
                <button class="primary-button" type="submit">Add assignment</button>
              </form>
            </div>
            <div class="card">
              <h3>Filters</h3>
              <div class="filter-row">
                <select id="filter-class"></select>
                <select id="filter-status">
                  <option value="all">All status</option>
                  <option value="active">Active</option>
                  <option value="completed">Completed</option>
                </select>
                <select id="filter-due">
                  <option value="all">All dates</option>
                  <option value="overdue">Overdue</option>
                  <option value="today">Due today</option>
                  <option value="upcoming">Due soon</option>
                </select>
              </div>
              <p class="muted" id="todo-count"></p>
            </div>
            <div class="card">
              <h3>Assignment list</h3>
              <div class="todo-list" id="todo-list"></div>
            </div>
          </div>
        </section>

        <section class="page" data-page="profile">
          <div class="card profile-card">
            <h3>Student profile</h3>
            <div class="details-grid">
              <div><span class="muted">Name</span><strong id="profile-name">Jordan Lee</strong></div>
              <div><span class="muted">Grade</span><strong id="profile-grade">11</strong></div>
              <div><span class="muted">School</span><strong id="profile-school">Not set</strong></div>
            </div>
          </div>
          <div class="card">
            <h3>Public profile</h3>
            <p class="muted">Your bio and photo show on your profile page.</p>
            <form class="profile-form" id="profile-form">
              <label>
                Bio
                <textarea id="profile-bio-input" placeholder="Write a short bio about yourself"></textarea>
              </label>
              <label>
                Profile photo
                <input type="file" id="profile-avatar-input" accept="image/*" />
              </label>
              <div class="profile-avatar-preview" id="profile-avatar-preview">No photo</div>
              <button class="primary-button" type="submit">Save profile</button>
            </form>
            <div class="profile-actions">
              <a class="ghost-button" id="view-profile-link" href="#">View my profile page</a>
            </div>
          </div>
          <div class="card">
            <h3>Settings</h3>
            <div class="settings-list" id="settings-list"></div>
          </div>
        </section>
      </main>
    </div>

    <nav class="bottom-nav">
      <button class="active" data-page-target="schedule">Schedule</button>
      <button data-page-target="chat">Chat</button>
      <button data-page-target="friends">Friends</button>
      <button data-page-target="study">Study</button>
      <button data-page-target="todo">To-Do</button>
      <button data-page-target="profile">Profile</button>
    </nav>

    <div class="feedback-widget" id="feedback-widget">
      <button class="feedback-toggle" id="feedback-toggle" type="button" aria-expanded="false" aria-controls="feedback-panel">
        <img src="assets/feedback-icon.png" alt="" />
        <span class="sr-only">Open feedback</span>
      </button>
      <div class="feedback-panel" id="feedback-panel" aria-hidden="true">
        <h4>Quick feedback</h4>
        <p class="muted">What's going wrong?</p>
        <form id="feedback-form">
          <textarea id="feedback-input" placeholder="Tell us what's wrong or missing"></textarea>
          <div class="feedback-actions">
            <button class="ghost-button" type="button" id="feedback-cancel">Close</button>
            <button class="primary-button" type="submit">Send</button>
          </div>
          <p class="feedback-status" id="feedback-status" role="status" aria-live="polite"></p>
        </form>
      </div>
    </div>

    <script>
      const dayOrder = ["Mon", "Tue", "Wed", "Thu", "Fri"];

      const createEmptySchedule = () => {
        const schedule = {};
        dayOrder.forEach((day) => {
          schedule[day] = [];
        });
        return schedule;
      };

      const demoProfiles = [
        {
          name: "Avery Chen",
          grade: "10",
        },
        {
          name: "Jordan Park",
          grade: "11",
        },
        {
          name: "Maya Ortiz",
          grade: "12",
        },
        {
          name: "Elliot Brooks",
          grade: "9",
        },
      ];

      const pickRandom = (list) => list[Math.floor(Math.random() * list.length)];
      const activeProfile = pickRandom(demoProfiles);

      const formatInputDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      };

      const addDays = (base, days) => {
        const next = new Date(base);
        next.setDate(base.getDate() + days);
        return next;
      };

      const buildTodosSeed = () => {
        const classIds = mockData.classes.map((item) => item.id).filter(Boolean);
        if (!classIds.length) {
          return [];
        }
        const username = String(activeProfile.name || "").trim().toLowerCase();
        const today = new Date();
        const makeDue = (offset) => formatInputDate(addDays(today, offset));
        const templatesByUser = {
          vlad: [
            { title: "Finish AP CS binary search notes", offset: 1, notes: "Add edge cases from class." },
            { title: "Bio quiz practice", offset: 2, notes: "Review vocab terms 1-20." },
            { title: "History DBQ outline", offset: 3, notes: "Thesis + 3 body claims." },
          ],
          luna: [
            { title: "Algebra worksheet corrections", offset: 1, notes: "Rework missed problems." },
            { title: "English reading response", offset: 2, notes: "Use two direct quotes." },
            { title: "Chem lab conclusion", offset: 4, notes: "Submit before Friday." },
          ],
          nina: [
            { title: "Spanish vocab check", offset: 1, notes: "Practice unit 5 verbs." },
            { title: "Geometry proofs review", offset: 3, notes: "Focus on angle theorems." },
            { title: "Prepare group presentation slides", offset: 4, notes: "Final review with team." },
          ],
          omar: [
            { title: "Physics problem set", offset: 2, notes: "Show all work for full credit." },
            { title: "World history flashcards", offset: 3, notes: "30 terms minimum." },
            { title: "Draft essay intro paragraph", offset: 5, notes: "Bring printed copy." },
          ],
          sam: [
            { title: "Study hall planning checklist", offset: 1, notes: "Prioritize week tasks." },
            { title: "Chem equations practice", offset: 2, notes: "Balance ten equations." },
            { title: "Math challenge packet", offset: 5, notes: "Attempt bonus section." },
          ],
        };
        const templates = templatesByUser[username] || templatesByUser.vlad;
        return templates.map((item, index) => ({
          id: `seed-todo-${username || "user"}-${index + 1}`,
          classId: classIds[index % classIds.length],
          title: item.title,
          dueDate: makeDue(item.offset),
          notes: item.notes,
          completed: false,
        }));
      };

      const shiftTime = (time, minutes) => {
        const [hours, mins] = time.split(":").map(Number);
        const base = new Date(2000, 0, 1, hours, mins);
        base.setMinutes(base.getMinutes() + minutes);
        const nextHours = base.getHours();
        const nextMinutes = String(base.getMinutes()).padStart(2, "0");
        return `${nextHours}:${nextMinutes}`;
      };

      const shiftSchedule = (scheduleMap, minutes) => {
        const shifted = {};
        dayOrder.forEach((day) => {
          shifted[day] = scheduleMap[day].map((entry) => ({
            ...entry,
            start: shiftTime(entry.start, minutes),
            end: shiftTime(entry.end, minutes),
          }));
        });
        return shifted;
      };

      const baseSchedule = {
        Mon: [
          { classId: "alg2", start: "8:10", end: "9:00", period: 1 },
          { classId: "hist", start: "9:05", end: "9:55", period: 2 },
          { classId: "chem", start: "10:05", end: "10:55", period: 3 },
          { classId: "span", start: "11:05", end: "11:55", period: 4 },
          { classId: "write", start: "1:15", end: "2:05", period: 5 },
        ],
        Tue: [
          { classId: "alg2", start: "8:10", end: "9:00", period: 1 },
          { classId: "cs", start: "9:05", end: "9:55", period: 2 },
          { classId: "chem", start: "10:05", end: "10:55", period: 3 },
          { classId: "span", start: "11:05", end: "11:55", period: 4 },
          { classId: "pe", start: "1:15", end: "2:05", period: 5 },
        ],
        Wed: [
          { classId: "alg2", start: "8:10", end: "9:00", period: 1 },
          { classId: "hist", start: "9:05", end: "9:55", period: 2 },
          { classId: "chem", start: "10:05", end: "10:55", period: 3 },
          { classId: "write", start: "11:05", end: "11:55", period: 4 },
          { classId: "study", start: "1:15", end: "2:05", period: 5 },
        ],
        Thu: [
          { classId: "alg2", start: "8:10", end: "9:00", period: 1 },
          { classId: "cs", start: "9:05", end: "9:55", period: 2 },
          { classId: "chem", start: "10:05", end: "10:55", period: 3 },
          { classId: "span", start: "11:05", end: "11:55", period: 4 },
          { classId: "club", start: "1:15", end: "2:20", period: 5 },
        ],
        Fri: [
          { classId: "alg2", start: "8:10", end: "9:00", period: 1 },
          { classId: "hist", start: "9:05", end: "9:55", period: 2 },
          { classId: "chem", start: "10:05", end: "10:55", period: 3 },
          { classId: "span", start: "11:05", end: "11:55", period: 4 },
          { classId: "write", start: "1:15", end: "2:05", period: 5 },
        ],
      };

      const scheduleVariants = [
        baseSchedule,
        shiftSchedule(baseSchedule, 45),
        shiftSchedule(baseSchedule, -20),
      ];

      const activeSchedule = pickRandom(scheduleVariants);

      const mockData = {
        classes: [
          {
            id: "alg2",
            name: "Algebra II",
            room: "B214",
            color: "#2de2a6",
            classmates: [],
          },
          {
            id: "hist",
            name: "US History",
            room: "C103",
            color: "#4ac8ff",
            classmates: [],
          },
          {
            id: "chem",
            name: "Chemistry",
            room: "Lab 2",
            color: "#ffb347",
            classmates: [],
          },
          {
            id: "write",
            name: "Creative Writing",
            room: "E201",
            color: "#ff7a63",
            classmates: [],
          },
          {
            id: "span",
            name: "Spanish 3",
            room: "D110",
            color: "#6bdcff",
            classmates: [],
          },
          {
            id: "cs",
            name: "Computer Science",
            room: "Tech 5",
            color: "#3bdc8b",
            classmates: [],
          },
          {
            id: "pe",
            name: "Wellness",
            room: "Gym",
            color: "#ffd166",
            classmates: [],
          },
          {
            id: "study",
            name: "Study Hall",
            room: "Library",
            color: "#9aa3b2",
            classmates: [],
          },
          {
            id: "club",
            name: "Robotics Club",
            room: "Lab 4",
            color: "#7cf2d8",
            classmates: [],
          },
        ],
        schedules: {
          my: activeSchedule,
        },
        chats: {
          alg2: [
            { sender: "Mia", text: "Anyone understand the last problem set?", time: "2:12 PM" },
            { sender: "You", text: "I can share notes after practice.", time: "2:16 PM", mine: true },
          ],
          hist: [
            { sender: "Riley", text: "Quiz on Friday. Flashcards?", time: "1:09 PM" },
            { sender: "You", text: "Yes, making a deck now.", time: "1:11 PM", mine: true },
          ],
          chem: [
            { sender: "Avery", text: "Lab report due Monday.", time: "11:42 AM" },
            { sender: "You", text: "Got it, thanks.", time: "11:45 AM", mine: true },
          ],
          cs: [
            { sender: "Devon", text: "Project groups posted in Orbit.", time: "9:02 AM" },
          ],
        },
        todosSeed: buildTodosSeed(),
        settings: [
          { id: "notifications", label: "Notifications", default: true },
          { id: "reminders", label: "Study reminders", default: true },
          { id: "classmate", label: "Show classmate schedule", default: true },
          { id: "midnight", label: "Midnight glow theme", default: false },
          { id: "reduceMotion", label: "Reduce motion", default: false },
        ],
      };

      const state = {
        page: "schedule",
        scheduleView: "my",
        selectedClass: null,
        scheduleExtras: [],
        scheduleSetup: {
          active: false,
          type: null,
        },
        chatMode: "classes",
        chatTarget: null,
        todos: [],
        settings: {},
      };

      const classmateState = {
        username: "",
        name: "Add a friend",
        schedule: createEmptySchedule(),
        classes: [],
        loaded: false,
      };

      const getActiveStorageScope = () => {
        const username = String(activeProfile.name || "").trim().toLowerCase();
        return username || "guest";
      };

      const scopedStorageKey = (baseKey) => `${baseKey}:${getActiveStorageScope()}`;

      const readScopedOrLegacy = (baseKey, fallback) => {
        try {
          const scopedRaw = localStorage.getItem(scopedStorageKey(baseKey));
          if (scopedRaw !== null) {
            return JSON.parse(scopedRaw);
          }
          const legacyRaw = localStorage.getItem(baseKey);
          if (legacyRaw !== null) {
            const parsed = JSON.parse(legacyRaw);
            localStorage.setItem(scopedStorageKey(baseKey), JSON.stringify(parsed));
            return parsed;
          }
        } catch (error) {
          return fallback;
        }
        return fallback;
      };

      const classmateStorageKey = () => scopedStorageKey("orbitClassmate");

      const chatState = {
        threads: {},
      };

      const friendsState = {
        items: [],
      };

      const friendsPageState = {
        search: "",
        selectedUsername: "",
        name: "",
        schedule: createEmptySchedule(),
        classes: [],
        loaded: false,
        loading: false,
        error: "",
        dayFilter: "all",
      };

      const friendRequestsState = {
        incoming: [],
        outgoing: [],
      };

      const profileState = {
        bio: "",
        avatar: "",
        school: "",
      };

      const groupsState = {
        items: [],
      };

      const storage = {
        get(key, fallback) {
          try {
            const value = localStorage.getItem(key);
            return value ? JSON.parse(value) : fallback;
          } catch (error) {
            return fallback;
          }
        },
        set(key, value) {
          localStorage.setItem(key, JSON.stringify(value));
        },
      };

      const settingsStorage = {
        async load() {
          try {
            const response = await fetch("/api/settings");
            if (response.status === 401) {
              window.location.href = "/signin";
              return {};
            }
            if (!response.ok) {
              throw new Error("Settings load failed");
            }
            const data = await response.json();
            return data.settings && typeof data.settings === "object" ? data.settings : {};
          } catch (error) {
            return storage.get("orbitSettings", {});
          }
        },
        async save(settings) {
          try {
            const response = await fetch("/api/settings", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ settings }),
            });
            if (response.status === 401) {
              window.location.href = "/signin";
              return;
            }
            if (!response.ok) {
              throw new Error("Settings save failed");
            }
          } catch (error) {
            storage.set("orbitSettings", settings);
          }
        },
      };

      const pageTitles = {
        schedule: {
          title: "Schedule",
          subtitle: "Your week at a glance, ready to adjust in seconds.",
        },
        chat: {
          title: "Chat",
          subtitle: "Classes, friends, and group threads in one place.",
        },
        friends: {
          title: "Friends",
          subtitle: "Add friends, search, and check out shared schedules.",
        },
        study: {
          title: "Study",
          subtitle: "Flashcards, practice, tests, and matching from your own cards.",
        },
        todo: {
          title: "To-Do",
          subtitle: "Assignments tied to classes with smart due reminders.",
        },
        profile: {
          title: "Profile",
          subtitle: "Personalize Orbit and manage preferences.",
        },
      };

      const elements = {
        pageTitle: document.getElementById("page-title"),
        pageSubtitle: document.getElementById("page-subtitle"),
        authStatus: document.getElementById("auth-status"),
        logoutButton: document.getElementById("logout-button"),
        userAvatar: document.getElementById("user-avatar"),
        userName: document.getElementById("user-name"),
        userGrade: document.getElementById("user-grade"),
        mobileUser: document.getElementById("mobile-user"),
        sidebarName: document.getElementById("sidebar-name"),
        profileName: document.getElementById("profile-name"),
        profileGrade: document.getElementById("profile-grade"),
        profileSchool: document.getElementById("profile-school"),
        profileForm: document.getElementById("profile-form"),
        profileBioInput: document.getElementById("profile-bio-input"),
        profileAvatarInput: document.getElementById("profile-avatar-input"),
        profileAvatarPreview: document.getElementById("profile-avatar-preview"),
        viewProfileLink: document.getElementById("view-profile-link"),
        classmateName: document.getElementById("classmate-name"),
        classmateSelect: document.getElementById("classmate-select"),
        scheduleGrid: document.getElementById("schedule-grid"),
        scheduleToggle: document.getElementById("schedule-toggle"),
        classDetailsGrid: document.getElementById("class-details-grid"),
        countdownStatus: document.getElementById("countdown-status"),
        countdownTime: document.getElementById("countdown-time"),
        countdownMeta: document.getElementById("countdown-meta"),
        scheduleForm: document.getElementById("schedule-form"),
        scheduleDay: document.getElementById("schedule-day"),
        scheduleTitle: document.getElementById("schedule-title"),
        scheduleStart: document.getElementById("schedule-start"),
        scheduleEnd: document.getElementById("schedule-end"),
        scheduleLocation: document.getElementById("schedule-location"),
        scheduleType: document.getElementById("schedule-type"),
        scheduleSetup: document.getElementById("schedule-setup"),
        scheduleSetupOptions: document.getElementById("setup-options"),
        scheduleSetupSchool: document.getElementById("setup-school"),
        scheduleSetupDetails: document.getElementById("setup-details"),
        scheduleSetupForms: document.getElementById("setup-forms"),
        scheduleSetupNote: document.getElementById("setup-note"),
        scheduleSetupStep: document.getElementById("setup-step"),
        scheduleSetupError: document.getElementById("setup-error"),
        scheduleSetupBack: document.getElementById("setup-back"),
        scheduleSetupSave: document.getElementById("setup-save"),
        chatModeToggle: document.getElementById("chat-mode-toggle"),
        chatClassList: document.getElementById("chat-class-list"),
        chatMessages: document.getElementById("chat-messages"),
        chatTitle: document.getElementById("chat-title"),
        chatSubtitle: document.getElementById("chat-subtitle"),
        chatForm: document.getElementById("chat-form"),
        chatInput: document.getElementById("chat-input"),
        chatNewGroup: document.getElementById("chat-new-group"),
        groupForm: document.getElementById("group-form"),
        groupName: document.getElementById("group-name"),
        groupMembers: document.getElementById("group-members"),
        todoForm: document.getElementById("todo-form"),
        todoClass: document.getElementById("todo-class"),
        todoTitle: document.getElementById("todo-title"),
        todoDue: document.getElementById("todo-due"),
        todoNotes: document.getElementById("todo-notes"),
        filterClass: document.getElementById("filter-class"),
        filterStatus: document.getElementById("filter-status"),
        filterDue: document.getElementById("filter-due"),
        todoList: document.getElementById("todo-list"),
        todoCount: document.getElementById("todo-count"),
        friendForm: document.getElementById("friend-form"),
        friendName: document.getElementById("friend-name"),
        friendList: document.getElementById("friend-list"),
        friendRequestsIncoming: document.getElementById("friend-requests-incoming"),
        friendRequestsOutgoing: document.getElementById("friend-requests-outgoing"),
        friendSearch: document.getElementById("friend-search"),
        friendScheduleGrid: document.getElementById("friend-schedule-grid"),
        friendScheduleTitle: document.getElementById("friend-schedule-title"),
        friendScheduleSubtitle: document.getElementById("friend-schedule-subtitle"),
        friendScheduleDay: document.getElementById("friend-schedule-day"),
        settingsList: document.getElementById("settings-list"),
        feedbackWidget: document.getElementById("feedback-widget"),
        feedbackToggle: document.getElementById("feedback-toggle"),
        feedbackPanel: document.getElementById("feedback-panel"),
        feedbackForm: document.getElementById("feedback-form"),
        feedbackInput: document.getElementById("feedback-input"),
        feedbackCancel: document.getElementById("feedback-cancel"),
        feedbackStatus: document.getElementById("feedback-status"),
      };

      const studyElements = {
        root: document.getElementById("study-root"),
        selectStage: document.querySelector('[data-study-stage="select"]'),
        workspaceStage: document.querySelector('[data-study-stage="workspace"]'),
        publicList: document.getElementById("study-public-list"),
        privateList: document.getElementById("study-private-list"),
        enterWorkspace: document.getElementById("study-enter-workspace"),
        continueSet: document.getElementById("study-continue"),
        backSelect: document.getElementById("study-back-select"),
        editToggle: document.getElementById("study-edit-toggle"),
        workspaceViewStudy: document.querySelector('[data-study-view="study"]'),
        workspaceViewEdit: document.querySelector('[data-study-view="edit"]'),
        workspaceTitle: document.getElementById("study-workspace-title"),
        workspaceSubtitle: document.getElementById("study-workspace-subtitle"),
        setList: document.getElementById("study-set-list"),
        setForm: document.getElementById("study-set-form"),
        setTitle: document.getElementById("study-set-title"),
        setDescription: document.getElementById("study-set-description"),
        setPublic: document.getElementById("study-set-public"),
        cardForm: document.getElementById("study-card-form"),
        cardTerm: document.getElementById("study-card-term"),
        cardDefinition: document.getElementById("study-card-definition"),
        cardList: document.getElementById("study-card-list"),
        importForm: document.getElementById("study-import-form"),
        importText: document.getElementById("study-import-text"),
        importDelimiter: document.getElementById("study-import-delimiter"),
        importCustomWrap: document.getElementById("study-import-custom-wrap"),
        importCustom: document.getElementById("study-import-custom"),
        importStatus: document.getElementById("study-import-status"),
        modeToggle: document.getElementById("study-mode-toggle"),
        flashcard: document.getElementById("flashcard"),
        flashFront: document.getElementById("flashcard-front"),
        flashBack: document.getElementById("flashcard-back"),
        flashPrev: document.getElementById("flashcard-prev"),
        flashNext: document.getElementById("flashcard-next"),
        flashProgress: document.getElementById("flashcard-progress"),
        flashShuffle: document.getElementById("flashcard-shuffle"),
        flashStar: document.getElementById("flashcard-star"),
        flashSubtitle: document.getElementById("flashcard-subtitle"),
        practiceTypeToggle: document.getElementById("practice-type-toggle"),
        practiceCard: document.getElementById("practice-card"),
        testCount: document.getElementById("test-count"),
        testStart: document.getElementById("test-start"),
        testCard: document.getElementById("test-card"),
        matchTerms: document.getElementById("match-terms"),
        matchDefinitions: document.getElementById("match-definitions"),
        matchStatus: document.getElementById("match-status"),
        matchTimer: document.getElementById("match-timer"),
        matchReset: document.getElementById("match-reset"),
      };

      const getClassById = (id) => mockData.classes.find((item) => item.id === id);

      const formatTimeRange = (start, end) => `${start} - ${end}`;

      const parseTimeToMinutes = (time) => {
        const [hours, minutes] = time.split(":").map(Number);
        return hours * 60 + minutes;
      };

      const scheduleTypeColors = {
        club: "#4ac8ff",
        practice: "#ffb347",
        study: "#2de2a6",
        personal: "#9aa3b2",
      };

      const classColorPalette = [
        "#2de2a6",
        "#4ac8ff",
        "#ffb347",
        "#ff7a63",
        "#6bdcff",
        "#3bdc8b",
        "#ffd166",
        "#9aa3b2",
        "#7cf2d8",
      ];

      const applyDemoProfile = () => {
        const name = activeProfile.name;
        setAvatar(elements.userAvatar, name, profileState.avatar);
        elements.userName.textContent = name;
        elements.userGrade.textContent = `Grade ${activeProfile.grade}`;
        elements.mobileUser.textContent = `Signed in as ${name}`;
        if (elements.authStatus) {
          elements.authStatus.textContent = `Signed in as ${name}`;
        }
        elements.sidebarName.textContent = name;
        elements.profileName.textContent = name;
        elements.profileGrade.textContent = activeProfile.grade;
        if (elements.profileSchool) {
          elements.profileSchool.textContent = profileState.school || "Not set";
        }
        if (elements.classmateName) {
          elements.classmateName.textContent = classmateState.name || "Add a friend";
        }
        if (elements.viewProfileLink) {
          elements.viewProfileLink.href = `/u/${encodeURIComponent(name)}`;
        }
      };

      const buildInitials = (name) =>
        name
          .split(" ")
          .filter(Boolean)
          .map((part) => part[0].toUpperCase())
          .slice(0, 2)
          .join("");

      const setAvatar = (element, name, avatarUrl) => {
        if (!element) {
          return;
        }
        element.innerHTML = "";
        element.classList.toggle("has-image", !!avatarUrl);
        if (avatarUrl) {
          const img = document.createElement("img");
          img.src = avatarUrl;
          img.alt = `${name} avatar`;
          element.appendChild(img);
          return;
        }
        const initials = buildInitials(name);
        element.textContent = initials || "OR";
      };

      const buildClassmates = () => [];

      const normalizeServerClasses = (classes) => {
        if (!Array.isArray(classes) || !classes.length) {
          return null;
        }
        const normalized = classes
          .map((entry, index) => {
            if (!entry) {
              return null;
            }
            const id = String(entry.id || "").trim();
            const name = String(entry.name || "").trim();
            if (!id || !name) {
              return null;
            }
            return {
              id,
              name,
              room: String(entry.room || "TBD").trim(),
              color: String(entry.color || "#4ac8ff").trim(),
              classmates: buildClassmates(index),
            };
          })
          .filter(Boolean);
        return normalized.length ? normalized : null;
      };

      const normalizeServerSchedule = (schedule) => {
        if (!schedule || typeof schedule !== "object") {
          return null;
        }
        const normalized = {};
        let hasEntries = false;
        dayOrder.forEach((day) => {
          const entries = Array.isArray(schedule[day]) ? schedule[day] : [];
          const cleaned = entries
            .filter((entry) => entry && entry.classId)
            .map((entry) => ({
              classId: String(entry.classId),
              start: String(entry.start || "").trim(),
              end: String(entry.end || "").trim(),
            }))
            .filter((entry) => entry.start && entry.end);
          cleaned.sort((a, b) => parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start));
          cleaned.forEach((entry, index) => {
            entry.period = index + 1;
          });
          if (cleaned.length) {
            hasEntries = true;
          }
          normalized[day] = cleaned;
        });
        return hasEntries ? normalized : null;
      };

      const applyServerData = (data) => {
        if (!data || typeof data !== "object") {
          return;
        }
        const serverClasses = normalizeServerClasses(data.classes);
        if (serverClasses) {
          mockData.classes = serverClasses;
        }
        const serverSchedule = normalizeServerSchedule(data.schedule);
        if (serverSchedule) {
          mockData.schedules.my = serverSchedule;
        }
      };

      const loadUser = async () => {
        try {
          const response = await fetch("/api/me");
          if (response.status === 401) {
            window.location.href = "/signin";
            return null;
          }
          if (!response.ok) {
            throw new Error("Failed to load user");
          }
          const data = await response.json();
          if (data && data.username) {
            activeProfile.name = data.username;
            return data.username;
          }
        } catch (error) {
          return null;
        }
        return null;
      };

      const applyProfileForm = () => {
        if (elements.profileBioInput) {
          elements.profileBioInput.value = profileState.bio || "";
        }
        if (elements.profileAvatarPreview) {
          elements.profileAvatarPreview.innerHTML = "";
          if (profileState.avatar) {
            const img = document.createElement("img");
            img.src = profileState.avatar;
            img.alt = "Profile preview";
            elements.profileAvatarPreview.appendChild(img);
          } else {
            elements.profileAvatarPreview.textContent = "No photo";
          }
        }
      };

      const loadProfile = async () => {
        try {
          const response = await fetch("/api/profile");
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Profile load failed");
          }
          const data = await response.json();
          const profile = data.profile || {};
          profileState.bio = profile.bio || "";
          profileState.avatar = profile.avatar || "";
          profileState.school = profile.school || "";
        } catch (error) {
          profileState.bio = "";
          profileState.avatar = "";
          profileState.school = "";
        }
        applyProfileForm();
      };

      const saveProfile = async () => {
        try {
          const response = await fetch("/api/profile", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              profile: { bio: profileState.bio, avatar: profileState.avatar, school: profileState.school },
            }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return false;
          }
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            if (data.error) {
              window.alert(data.error);
            }
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      };

      const loadServerData = async () => {
        try {
          const response = await fetch("/api/data");
          if (response.status === 401) {
            window.location.href = "/signin";
            return null;
          }
          if (!response.ok) {
            throw new Error("Failed to load data");
          }
          const data = await response.json();
          applyServerData(data);
          return data;
        } catch (error) {
          return null;
        }
      };

      const isScheduleEmpty = (schedule) => {
        if (!schedule || typeof schedule !== "object") {
          return true;
        }
        return dayOrder.every((day) => !Array.isArray(schedule[day]) || schedule[day].length === 0);
      };

      const buildEmptySchedule = () => {
        return createEmptySchedule();
      };

      const buildSchedulePayload = () => {
        const schedule = {};
        dayOrder.forEach((day) => {
          const entries = Array.isArray(mockData.schedules.my[day]) ? mockData.schedules.my[day] : [];
          schedule[day] = entries.map((entry, index) => ({
            id: entry.id || `event-${day}-${index}-${Date.now()}`,
            classId: entry.classId,
            start: entry.start,
            end: entry.end,
            location: entry.location || "",
          }));
        });
        return schedule;
      };

      const shouldStartScheduleSetup = (serverData) => {
        if (!serverData || typeof serverData !== "object") {
          return false;
        }
        return isScheduleEmpty(serverData.schedule);
      };

      const maybeSeedServerData = async (serverData) => {
        if (!serverData || typeof serverData !== "object") {
          return;
        }
        const hasClasses = Array.isArray(serverData.classes) && serverData.classes.length > 0;
        const scheduleEmpty = isScheduleEmpty(serverData.schedule);
        if (hasClasses && !scheduleEmpty) {
          return;
        }
        try {
          const payload = {
            classes: mockData.classes,
            schedule: buildSchedulePayload(),
          };
          const response = await fetch("/api/data", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            throw new Error("Seed failed");
          }
        } catch (error) {
          return;
        }
      };

      const initAuth = () => {
        if (!elements.logoutButton) {
          return;
        }
        elements.logoutButton.addEventListener("click", async () => {
          try {
            await fetch("/api/logout", { method: "POST" });
          } finally {
            window.location.href = "/signin";
          }
        });
      };

      const buildScheduleMap = () => {
        const baseSchedule =
          state.scheduleView === "my"
            ? mockData.schedules.my
            : classmateState.schedule || buildEmptySchedule();
        const map = {};
        dayOrder.forEach((day) => {
          const dayEntries = Array.isArray(baseSchedule[day]) ? baseSchedule[day] : [];
          const entries = dayEntries.map((entry) => ({
            id: `${day}-${entry.classId}-${entry.start}`,
            type: "class",
            ...entry,
          }));
          if (state.scheduleView === "my") {
            const extras = state.scheduleExtras.filter((item) => item.day === day);
            extras.forEach((item) => {
              entries.push({
                id: item.id,
                type: "custom",
                title: item.title,
                start: item.start,
                end: item.end,
                location: item.location,
                scheduleType: item.scheduleType,
              });
            });
          }
          entries.sort((a, b) => parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start));
          map[day] = entries;
        });
        return map;
      };

      const setPage = (page) => {
        if (!page || !pageTitles[page]) {
          return;
        }
        state.page = page;
        document.querySelectorAll(".page").forEach((section) => {
          section.classList.toggle("active", section.dataset.page === page);
        });
        document.querySelectorAll("[data-page-target]").forEach((button) => {
          button.classList.toggle("active", button.dataset.pageTarget === page);
        });
        if (elements.pageTitle) {
          elements.pageTitle.textContent = pageTitles[page].title;
        }
        if (elements.pageSubtitle) {
          elements.pageSubtitle.textContent = pageTitles[page].subtitle;
        }
      };

      const renderSchedule = () => {
        const schedule = buildScheduleMap();
        if (!state.selectedClass) {
          const firstDay = dayOrder[0];
          state.selectedClass = { day: firstDay, entryId: schedule[firstDay][0]?.id || null };
        }
        elements.scheduleGrid.innerHTML = "";

        dayOrder.forEach((day) => {
          const dayCard = document.createElement("div");
          dayCard.className = "schedule-day";
          const header = document.createElement("h4");
          header.textContent = day;
          dayCard.appendChild(header);

          schedule[day].forEach((entry) => {
            const classInfo = entry.type === "class" ? getScheduleClassById(entry.classId) : null;
            const button = document.createElement("button");
            button.className = "class-item";
            const accentColor =
              entry.type === "class" && classInfo
                ? classInfo.color
                : scheduleTypeColors[entry.scheduleType] || "#4ac8ff";
            button.style.setProperty("--accent-color", accentColor);
            if (state.selectedClass && state.selectedClass.entryId === entry.id && state.selectedClass.day === day) {
              button.classList.add("active");
            }
            const title = entry.type === "class" ? (classInfo ? classInfo.name : "Class") : entry.title;
            const periodLabel =
              entry.type === "class" && entry.period ? ` · Period ${entry.period}` : entry.type === "class" ? "" : "";
            button.innerHTML = `
              <div>${title}</div>
              <small>${formatTimeRange(entry.start, entry.end)}${entry.type === "class" ? periodLabel : " · Event"}</small>
            `;
            button.addEventListener("click", () => {
              state.selectedClass = { day, entryId: entry.id };
              renderSchedule();
              renderClassDetails();
            });
            dayCard.appendChild(button);
          });

          elements.scheduleGrid.appendChild(dayCard);
        });

        renderClassDetails();
        updateCountdown(schedule);
        setScheduleFormState();
      };

      const setScheduleFormState = () => {
        const isMySchedule = state.scheduleView === "my";
        elements.scheduleForm.querySelectorAll("input, select, button").forEach((field) => {
          field.disabled = !isMySchedule;
        });
        if (!isMySchedule) {
          elements.scheduleTitle.placeholder = "Switch to My schedule to add items";
        } else {
          elements.scheduleTitle.placeholder = "Activity title";
        }
      };

      const getClassmateClassById = (id) =>
        classmateState.classes.find((item) => item && item.id === id);

      const getScheduleClassById = (id) =>
        state.scheduleView === "classmate" ? getClassmateClassById(id) : getClassById(id);

      const setScheduleView = (view) => {
        if (!view || !elements.scheduleToggle) {
          return;
        }
        if (view === "classmate" && !classmateState.username) {
          return;
        }
        state.scheduleView = view;
        elements.scheduleToggle.querySelectorAll("button").forEach((btn) => btn.classList.remove("active"));
        const targetButton = elements.scheduleToggle.querySelector(`[data-schedule-view="${view}"]`);
        if (targetButton) {
          targetButton.classList.add("active");
        }
        state.selectedClass = null;
        renderSchedule();
        updateClassmateSelectVisibility();
      };

      const updateClassmateLabel = () => {
        if (elements.classmateName) {
          elements.classmateName.textContent = classmateState.name || "Add a friend";
        }
      };

      const updateClassmateToggleState = () => {
        if (!elements.scheduleToggle) {
          return;
        }
        const button = elements.scheduleToggle.querySelector('[data-schedule-view="classmate"]');
        if (!button) {
          return;
        }
        const hasClassmate = !!classmateState.username;
        button.disabled = !hasClassmate;
        if (!hasClassmate && state.scheduleView === "classmate") {
          setScheduleView("my");
        }
      };

      const updateClassmateSelectVisibility = () => {
        if (!elements.classmateSelect) {
          return;
        }
        elements.classmateSelect.hidden = state.scheduleView !== "classmate" || !classmateState.username;
      };

      const getFriendOptions = () =>
        friendsState.items
          .map((friend) => {
            if (!friend) {
              return null;
            }
            const username = friend.username || friend.name;
            if (!username) {
              return null;
            }
            return {
              username,
              label: friend.name || username,
            };
          })
          .filter(Boolean);

      const updateClassmateSelectOptions = (options, selectedUsername) => {
        if (!elements.classmateSelect) {
          return;
        }
        elements.classmateSelect.innerHTML = "";
        if (!options.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No friends yet";
          elements.classmateSelect.appendChild(option);
          elements.classmateSelect.disabled = true;
          elements.classmateSelect.hidden = true;
          return;
        }
        options.forEach((optionData) => {
          const option = document.createElement("option");
          option.value = optionData.username;
          option.textContent = optionData.label;
          elements.classmateSelect.appendChild(option);
        });
        elements.classmateSelect.disabled = false;
        if (selectedUsername) {
          elements.classmateSelect.value = selectedUsername;
        }
      };

      const resetClassmateState = () => {
        classmateState.username = "";
        classmateState.name = "Add a friend";
        classmateState.schedule = createEmptySchedule();
        classmateState.classes = [];
        classmateState.loaded = false;
        storage.set(classmateStorageKey(), "");
        updateClassmateLabel();
        updateClassmateToggleState();
        updateClassmateSelectVisibility();
      };

      const loadClassmateSchedule = async (username) => {
        if (!username) {
          return null;
        }
        try {
          const response = await fetch(`/api/profile/${encodeURIComponent(username)}`);
          if (response.status === 401) {
            window.location.href = "/signin";
            return null;
          }
          if (!response.ok) {
            throw new Error("Classmate load failed");
          }
          const data = await response.json();
          return {
            username: data.username || username,
            classes: normalizeServerClasses(data.classes) || [],
            schedule: normalizeServerSchedule(data.schedule) || buildEmptySchedule(),
          };
        } catch (error) {
          return null;
        }
      };

      const selectClassmate = async (username, label) => {
        if (!username) {
          resetClassmateState();
          return;
        }
        if (classmateState.username === username && classmateState.loaded) {
          classmateState.name = label || classmateState.name;
          updateClassmateLabel();
          updateClassmateToggleState();
          updateClassmateSelectVisibility();
          return;
        }
        classmateState.username = username;
        classmateState.name = label || username;
        classmateState.schedule = createEmptySchedule();
        classmateState.classes = [];
        classmateState.loaded = false;
        storage.set(classmateStorageKey(), username);
        updateClassmateLabel();
        updateClassmateToggleState();
        updateClassmateSelectVisibility();

        const data = await loadClassmateSchedule(username);
        if (!data) {
          return;
        }
        classmateState.username = username;
        classmateState.name = label || data.username || username;
        classmateState.schedule = data.schedule || buildEmptySchedule();
        classmateState.classes = data.classes || [];
        classmateState.loaded = true;
        updateClassmateLabel();
        updateClassmateToggleState();
        updateClassmateSelectVisibility();
        if (state.scheduleView === "classmate") {
          state.selectedClass = null;
          renderSchedule();
        }
      };

      const syncClassmateSelection = async () => {
        const options = getFriendOptions();
        if (!options.length) {
          updateClassmateSelectOptions([]);
          resetClassmateState();
          return;
        }
        const stored = readScopedOrLegacy("orbitClassmate", "");
        const selected =
          options.find((option) => option.username.toLowerCase() === String(stored || "").toLowerCase()) ||
          options[0];
        updateClassmateSelectOptions(options, selected.username);
        await selectClassmate(selected.username, selected.label);
      };

      const scheduleSetupConfig = {
        daily: {
          note: "Same classes and times Monday through Friday.",
          sections: [{ key: "daily", label: "Daily schedule", actionLabel: "Add period" }],
          defaultRows: 5,
        },
        ab: {
          note: "Alternate A and B day schedules. Orbit maps Mon, Wed, Fri to A and Tue, Thu to B.",
          sections: [
            { key: "A", label: "A day", actionLabel: "Add period" },
            { key: "B", label: "B day", actionLabel: "Add period" },
          ],
          defaultRows: 4,
        },
        block: {
          note: "Longer class blocks with fewer classes per day. Fill in each weekday with its blocks.",
          sections: dayOrder.map((day) => ({ key: day, label: `${day} blocks`, actionLabel: "Add block" })),
          defaultRows: 4,
        },
      };

      const resetScheduleSetup = () => {
        state.scheduleSetup.type = null;
        if (elements.scheduleSetupOptions) {
          elements.scheduleSetupOptions.querySelectorAll("button").forEach((button) => {
            button.classList.remove("active");
          });
        }
        if (elements.scheduleSetupSchool) {
          elements.scheduleSetupSchool.value = profileState.school || "";
        }
        if (elements.scheduleSetupDetails) {
          elements.scheduleSetupDetails.hidden = true;
        }
        if (elements.scheduleSetupForms) {
          elements.scheduleSetupForms.innerHTML = "";
        }
        if (elements.scheduleSetupStep) {
          elements.scheduleSetupStep.textContent = "Step 1 of 2";
        }
        if (elements.scheduleSetupBack) {
          elements.scheduleSetupBack.hidden = true;
        }
        if (elements.scheduleSetupSave) {
          elements.scheduleSetupSave.disabled = true;
        }
        if (elements.scheduleSetupError) {
          elements.scheduleSetupError.textContent = "";
        }
      };

      const openScheduleSetup = () => {
        if (!elements.scheduleSetup) {
          return;
        }
        state.scheduleSetup.active = true;
        setPage("schedule");
        resetScheduleSetup();
        elements.scheduleSetup.classList.add("active");
        elements.scheduleSetup.setAttribute("aria-hidden", "false");
      };

      const closeScheduleSetup = () => {
        if (!elements.scheduleSetup) {
          return;
        }
        state.scheduleSetup.active = false;
        elements.scheduleSetup.classList.remove("active");
        elements.scheduleSetup.setAttribute("aria-hidden", "true");
      };

      const addSetupRow = (container) => {
        const row = document.createElement("div");
        row.className = "setup-row";
        row.innerHTML = `
          <input type="text" placeholder="Class name" data-field="name" />
          <input type="time" data-field="start" />
          <input type="time" data-field="end" />
          <input type="text" placeholder="Room (optional)" data-field="location" />
          <button class="ghost-button" type="button" data-remove-row>Remove</button>
        `;
        const removeButton = row.querySelector("[data-remove-row]");
        removeButton.addEventListener("click", () => {
          row.remove();
        });
        container.appendChild(row);
      };

      const buildSetupSection = (section, defaultRows) => {
        const wrapper = document.createElement("div");
        wrapper.className = "setup-day";
        wrapper.dataset.setupDay = section.key;
        wrapper.innerHTML = `
          <h4>${section.label}</h4>
          <div class="setup-rows" data-setup-rows></div>
        `;
        const rowsContainer = wrapper.querySelector("[data-setup-rows]");
        for (let i = 0; i < defaultRows; i += 1) {
          addSetupRow(rowsContainer);
        }
        const addButton = document.createElement("button");
        addButton.type = "button";
        addButton.className = "ghost-button setup-add";
        addButton.textContent = section.actionLabel;
        addButton.addEventListener("click", () => addSetupRow(rowsContainer));
        wrapper.appendChild(addButton);
        return wrapper;
      };

      const renderScheduleSetupForm = (type) => {
        const config = scheduleSetupConfig[type];
        if (!config || !elements.scheduleSetupForms) {
          return;
        }
        elements.scheduleSetupForms.innerHTML = "";
        if (elements.scheduleSetupNote) {
          elements.scheduleSetupNote.textContent = config.note;
        }
        config.sections.forEach((section) => {
          elements.scheduleSetupForms.appendChild(buildSetupSection(section, config.defaultRows));
        });
      };

      const selectScheduleSetupType = (type) => {
        if (!scheduleSetupConfig[type]) {
          return;
        }
        state.scheduleSetup.type = type;
        if (elements.scheduleSetupOptions) {
          elements.scheduleSetupOptions.querySelectorAll("button").forEach((button) => {
            button.classList.toggle("active", button.dataset.setupType === type);
          });
        }
        if (elements.scheduleSetupDetails) {
          elements.scheduleSetupDetails.hidden = false;
        }
        if (elements.scheduleSetupSave) {
          elements.scheduleSetupSave.disabled = false;
        }
        if (elements.scheduleSetupBack) {
          elements.scheduleSetupBack.hidden = false;
        }
        if (elements.scheduleSetupStep) {
          elements.scheduleSetupStep.textContent = "Step 2 of 2";
        }
        if (elements.scheduleSetupError) {
          elements.scheduleSetupError.textContent = "";
        }
        renderScheduleSetupForm(type);
      };

      const collectSetupEntries = (rowsContainer) => {
        const entries = [];
        let hasError = false;
        if (!rowsContainer) {
          return { entries, hasError: true };
        }
        rowsContainer.querySelectorAll(".setup-row").forEach((row) => {
          const name = row.querySelector('[data-field="name"]').value.trim();
          const start = row.querySelector('[data-field="start"]').value;
          const end = row.querySelector('[data-field="end"]').value;
          const location = row.querySelector('[data-field="location"]').value.trim();
          row.classList.remove("error");
          if (!name && !start && !end && !location) {
            return;
          }
          if (!name || !start || !end) {
            hasError = true;
            row.classList.add("error");
            return;
          }
          if (parseTimeToMinutes(start) >= parseTimeToMinutes(end)) {
            hasError = true;
            row.classList.add("error");
            return;
          }
          entries.push({ name, start, end, location });
        });
        return { entries, hasError };
      };

      const buildClassId = (name, usedIds) => {
        const base = name
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "");
        let id = base || `class-${usedIds.size + 1}`;
        let suffix = 1;
        while (usedIds.has(id)) {
          suffix += 1;
          id = `${base || "class"}-${suffix}`;
        }
        usedIds.add(id);
        return id;
      };

      const buildScheduleFromSetup = (type, sectionData) => {
        const classMap = new Map();
        const usedIds = new Set();
        const ensureClass = (name, location) => {
          const key = name.trim().toLowerCase();
          let classInfo = classMap.get(key);
          if (!classInfo) {
            const index = classMap.size;
            classInfo = {
              id: buildClassId(name, usedIds),
              name,
              room: location || "TBD",
              color: classColorPalette[index % classColorPalette.length],
              classmates: buildClassmates(index),
            };
            classMap.set(key, classInfo);
          } else if (location && classInfo.room === "TBD") {
            classInfo.room = location;
          }
          return classInfo.id;
        };

        const buildDayEntries = (entries) => {
          const dayEntries = entries.map((entry) => ({
            classId: ensureClass(entry.name, entry.location),
            start: entry.start,
            end: entry.end,
            location: entry.location || "",
          }));
          dayEntries.sort((a, b) => parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start));
          dayEntries.forEach((entry, index) => {
            entry.period = index + 1;
          });
          return dayEntries;
        };

        const schedule = buildEmptySchedule();
        if (type === "daily") {
          const template = sectionData.daily || [];
          dayOrder.forEach((day) => {
            schedule[day] = buildDayEntries(template);
          });
        } else if (type === "ab") {
          const aDay = sectionData.A || [];
          const bDay = sectionData.B || [];
          const pattern = { Mon: "A", Tue: "B", Wed: "A", Thu: "B", Fri: "A" };
          dayOrder.forEach((day) => {
            const template = pattern[day] === "A" ? aDay : bDay;
            schedule[day] = buildDayEntries(template);
          });
        } else {
          dayOrder.forEach((day) => {
            schedule[day] = buildDayEntries(sectionData[day] || []);
          });
        }

        return {
          classes: Array.from(classMap.values()),
          schedule,
        };
      };

      const saveScheduleToServer = async () => {
        try {
          const payload = {
            classes: mockData.classes,
            schedule: buildSchedulePayload(),
          };
          const response = await fetch("/api/data", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return false;
          }
          return response.ok;
        } catch (error) {
          return false;
        }
      };

      const saveScheduleSetup = async () => {
        if (!state.scheduleSetup.type || !elements.scheduleSetupForms) {
          return;
        }
        if (elements.scheduleSetupError) {
          elements.scheduleSetupError.textContent = "";
        }
        const sectionData = {};
        let hasError = false;
        elements.scheduleSetupForms.querySelectorAll(".setup-day").forEach((section) => {
          const rowsContainer = section.querySelector("[data-setup-rows]");
          const { entries, hasError: rowsError } = collectSetupEntries(rowsContainer);
          if (rowsError || !entries.length) {
            hasError = true;
          }
          sectionData[section.dataset.setupDay] = entries;
        });
        if (hasError) {
          if (elements.scheduleSetupError) {
            elements.scheduleSetupError.textContent =
              "Add at least one class with a start and end time in each section.";
          }
          return;
        }
        const built = buildScheduleFromSetup(state.scheduleSetup.type, sectionData);
        if (!built.classes.length) {
          if (elements.scheduleSetupError) {
            elements.scheduleSetupError.textContent = "Add at least one class to continue.";
          }
          return;
        }
        mockData.classes = built.classes;
        mockData.schedules.my = built.schedule;
        const saved = await saveScheduleToServer();
        if (!saved) {
          if (elements.scheduleSetupError) {
            elements.scheduleSetupError.textContent =
              "Could not save schedule. Check your connection and try again.";
          }
          return;
        }
        if (elements.scheduleSetupSchool) {
          profileState.school = elements.scheduleSetupSchool.value.trim();
          await saveProfile();
          applyDemoProfile();
        }
        closeScheduleSetup();
        state.scheduleView = "my";
        state.selectedClass = null;
        renderTodoSelectors();
        renderTodoList();
        renderSchedule();
        renderChatList();
        renderChatThread();
      };

      const initScheduleSetup = () => {
        if (!elements.scheduleSetup || !elements.scheduleSetupOptions) {
          return;
        }
        resetScheduleSetup();
        elements.scheduleSetupOptions.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => selectScheduleSetupType(button.dataset.setupType));
        });
        if (elements.scheduleSetupBack) {
          elements.scheduleSetupBack.addEventListener("click", resetScheduleSetup);
        }
        if (elements.scheduleSetupSave) {
          elements.scheduleSetupSave.addEventListener("click", saveScheduleSetup);
        }
      };

      const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

      const getNextScheduleEvent = (scheduleMap) => {
        const now = new Date();
        for (let offset = 0; offset < 7; offset += 1) {
          const date = new Date(now);
          date.setDate(now.getDate() + offset);
          const dayName = dayNames[date.getDay()];
          if (!dayOrder.includes(dayName)) {
            continue;
          }
          const entries = scheduleMap[dayName] || [];
          for (const entry of entries) {
            const [startHours, startMinutes] = entry.start.split(":").map(Number);
            const [endHours, endMinutes] = entry.end.split(":").map(Number);
            const start = new Date(date);
            const end = new Date(date);
            start.setHours(startHours, startMinutes, 0, 0);
            end.setHours(endHours, endMinutes, 0, 0);
            if (offset === 0) {
              if (now >= start && now <= end) {
                return { type: "current", entry, dayName, start, end };
              }
              if (now < start) {
                return { type: "upcoming", entry, dayName, start, end };
              }
            } else {
              return { type: "upcoming", entry, dayName, start, end };
            }
          }
        }
        return null;
      };

      const formatDuration = (ms) => {
        const totalSeconds = Math.max(0, Math.floor(ms / 1000));
        const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
        const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
        const seconds = String(totalSeconds % 60).padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      };

      const updateCountdown = (scheduleMap) => {
        const nextEvent = getNextScheduleEvent(scheduleMap);
        if (!nextEvent) {
          elements.countdownStatus.textContent = "No upcoming classes today.";
          elements.countdownTime.textContent = "--:--:--";
          elements.countdownMeta.textContent = "";
          elements.countdownTime.classList.remove("tick");
          return;
        }
        const now = new Date();
        const targetTime = nextEvent.type === "current" ? nextEvent.end : nextEvent.start;
        const timeLeft = targetTime - now;
        const entry = nextEvent.entry;
        const classInfo = entry.type === "class" ? getScheduleClassById(entry.classId) : null;
        const label =
          nextEvent.type === "current"
            ? entry.type === "class"
              ? "Time left in class"
              : "Time left in event"
            : entry.type === "class"
              ? "Time until next class"
              : "Time until next event";
        elements.countdownStatus.textContent = label;
        elements.countdownTime.textContent = formatDuration(timeLeft);
        const currentTime = now.toLocaleTimeString(undefined, {
          hour: "numeric",
          minute: "2-digit",
        });
        const entryName = entry.type === "class" ? (classInfo ? classInfo.name : "Class") : entry.title;
        elements.countdownMeta.innerHTML = `
          <span class="tag">${nextEvent.dayName}</span>
          <span>Now ${currentTime}</span>
          <span>${entryName}</span>
          <span>${formatTimeRange(entry.start, entry.end)}</span>
        `;
        elements.countdownTime.classList.remove("tick");
        void elements.countdownTime.offsetWidth;
        elements.countdownTime.classList.add("tick");
      };

      const renderClassDetails = () => {
        if (!state.selectedClass) {
          elements.classDetailsGrid.innerHTML = "";
          return;
        }
        const schedule = buildScheduleMap();
        const { day, entryId } = state.selectedClass;
        const entry = schedule[day]?.find((item) => item.id === entryId);
        if (!entry) {
          elements.classDetailsGrid.innerHTML = "";
          return;
        }
        if (entry.type === "class") {
          const classInfo = getScheduleClassById(entry.classId);
          if (!classInfo) {
            elements.classDetailsGrid.innerHTML = `
              <div><span>Class</span><strong>Unknown class</strong></div>
              <div><span>Day</span><strong>${day}</strong></div>
              <div><span>Time</span><strong>${formatTimeRange(entry.start, entry.end)}</strong></div>
            `;
            return;
          }
          const classmates = Array.isArray(classInfo.classmates) ? classInfo.classmates.join(", ") : "";
          const isMySchedule = state.scheduleView === "my";
          elements.classDetailsGrid.innerHTML = `
            <div><span>Class</span><strong>${classInfo.name}</strong></div>
            <div><span>Room</span><strong>${classInfo.room}</strong></div>
            <div><span>Day</span><strong>${day}</strong></div>
            <div><span>Time</span><strong>${formatTimeRange(entry.start, entry.end)}</strong></div>
            <div><span>Period</span><strong>${entry.period}</strong></div>
            <div><span>Classmates</span><strong>${classmates || "Not shared"}</strong></div>
            ${
              isMySchedule
                ? `<div><span>Chat</span><strong><button class="ghost-button" type="button" data-open-chat="${classInfo.id}">Open class chat</button></strong></div>`
                : `<div><span>Student</span><strong>${classmateState.name || "Friend"}</strong></div>`
            }
          `;
          if (isMySchedule) {
            const chatButton = elements.classDetailsGrid.querySelector("[data-open-chat]");
            if (chatButton) {
              chatButton.addEventListener("click", () => {
                state.chatMode = "classes";
                state.chatTarget = { type: "class", id: classInfo.id };
                setPage("chat");
                renderChatList();
                renderChatThread();
              });
            }
          }
        } else {
          elements.classDetailsGrid.innerHTML = `
            <div><span>Event</span><strong>${entry.title}</strong></div>
            <div><span>Day</span><strong>${day}</strong></div>
            <div><span>Time</span><strong>${formatTimeRange(entry.start, entry.end)}</strong></div>
            <div><span>Location</span><strong>${entry.location || "TBD"}</strong></div>
            <div><span>Type</span><strong>${entry.scheduleType}</strong></div>
            <div><span>Action</span><strong><button class="ghost-button" type="button" data-remove-event="${entry.id}">Remove event</button></strong></div>
          `;
          const removeButton = elements.classDetailsGrid.querySelector("[data-remove-event]");
          if (removeButton) {
            removeButton.addEventListener("click", () => {
              removeScheduleItem(entry.id);
            });
          }
        }
      };

      const getFriendByUsername = (username) => {
        const needle = String(username || "").toLowerCase();
        return friendsState.items.find((friend) => {
          const candidate = String(friend.username || friend.name || "").toLowerCase();
          return candidate === needle;
        });
      };

      const getGroupById = (id) => groupsState.items.find((group) => group.id === id);

      const getDmThreadId = (userA, userB) => {
        const pair = [userA, userB]
          .map((item) => String(item || "").trim())
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: "base" }));
        if (!pair.length) {
          return "dm:unknown";
        }
        return `dm:${pair.join(":")}`;
      };

      const getThreadIdForTarget = (target) => {
        if (!target) {
          return null;
        }
        if (target.type === "class") {
          return target.id;
        }
        if (target.type === "dm") {
          return getDmThreadId(activeProfile.name, target.id);
        }
        if (target.type === "group") {
          return `group:${target.id}`;
        }
        return null;
      };

      const ensureChatThread = (threadId) => {
        if (!threadId) {
          return [];
        }
        if (!chatState.threads[threadId]) {
          chatState.threads[threadId] = [];
        }
        return chatState.threads[threadId];
      };

      const getChatThread = (threadId) => chatState.threads[threadId] || [];

      const setChatMode = (mode) => {
        if (!mode) {
          return;
        }
        state.chatMode = mode;
        renderChatList();
        renderChatThread();
      };

      const loadChats = async () => {
        try {
          const response = await fetch("/api/chats");
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Chat load failed");
          }
          const data = await response.json();
          chatState.threads = data && typeof data.chats === "object" ? data.chats : {};
        } catch (error) {
          chatState.threads = {};
        }
      };

      const postChatMessage = async (target, text) => {
        if (!target) {
          return null;
        }
        try {
          const payload = { text };
          if (target.type === "class") {
            payload.classId = target.id;
          } else if (target.type === "dm") {
            payload.to = target.id;
          } else if (target.type === "group") {
            payload.groupId = target.id;
          }
          const response = await fetch("/api/chats", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return null;
          }
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            if (data.error) {
              window.alert(data.error);
            }
            return null;
          }
          return data.message
            ? {
                message: data.message,
                threadId: data.threadId || getThreadIdForTarget(target),
              }
            : null;
        } catch (error) {
          return null;
        }
      };

      const getChatListItems = (mode) => {
        if (mode === "classes") {
          return mockData.classes.map((item) => {
            const thread = getChatThread(item.id);
            const lastMessage = thread[thread.length - 1];
            return {
              type: "class",
              id: item.id,
              title: item.name,
              subtitle: lastMessage ? lastMessage.text : "No messages yet",
              threadId: item.id,
            };
          });
        }
        if (mode === "friends") {
          return friendsState.items
            .map((friend) => {
              const username = String(friend.username || friend.name || "").trim();
              if (!username) {
                return null;
              }
              const display = friend.name || friend.username || username;
              const threadId = getDmThreadId(activeProfile.name, username);
              const thread = getChatThread(threadId);
              const lastMessage = thread[thread.length - 1];
              return {
                type: "dm",
                id: username,
                title: display,
                subtitle: lastMessage ? lastMessage.text : "Direct message",
                threadId,
              };
            })
            .filter(Boolean);
        }
        if (mode === "groups") {
          return groupsState.items
            .map((group) => {
              if (!group || !group.id) {
                return null;
              }
              const threadId = `group:${group.id}`;
              const thread = getChatThread(threadId);
              const lastMessage = thread[thread.length - 1];
              const memberCount = Array.isArray(group.members) ? group.members.length : 0;
              return {
                type: "group",
                id: group.id,
                title: group.name || "Group chat",
                subtitle: lastMessage ? lastMessage.text : `${memberCount} members`,
                threadId,
              };
            })
            .filter(Boolean);
        }
        return [];
      };

      const renderChatList = () => {
        if (!elements.chatClassList) {
          return;
        }
        if (elements.chatModeToggle) {
          elements.chatModeToggle.querySelectorAll("button").forEach((button) => {
            button.classList.toggle("active", button.dataset.chatMode === state.chatMode);
          });
        }
        if (elements.groupForm) {
          elements.groupForm.style.display = state.chatMode === "groups" ? "grid" : "none";
        }
        const items = getChatListItems(state.chatMode);
        elements.chatClassList.innerHTML = "";
        if (!items.length) {
          const emptyMessage =
            state.chatMode === "classes"
              ? "No classes yet. Add one in Schedule."
              : state.chatMode === "friends"
                ? "No friends yet. Add one in Friends."
                : "No group chats yet. Create one to get started.";
          renderStudyEmpty(elements.chatClassList, emptyMessage);
          state.chatTarget = null;
          return;
        }
        const hasActive =
          state.chatTarget &&
          items.some((item) => item.type === state.chatTarget.type && item.id === state.chatTarget.id);
        if (!hasActive) {
          state.chatTarget = { type: items[0].type, id: items[0].id };
        }
        items.forEach((item) => {
          const button = document.createElement("button");
          button.className =
            state.chatTarget && state.chatTarget.type === item.type && state.chatTarget.id === item.id
              ? "active"
              : "";
          button.innerHTML = `
            <strong>${item.title}</strong>
            <small class="muted">${item.subtitle}</small>
          `;
          button.addEventListener("click", () => {
            state.chatTarget = { type: item.type, id: item.id };
            renderChatList();
            renderChatThread();
          });
          elements.chatClassList.appendChild(button);
        });
      };

      const renderChatThread = () => {
        const target = state.chatTarget;
        if (!target) {
          elements.chatMessages.innerHTML = "";
          elements.chatTitle.textContent = "Select a chat";
          elements.chatSubtitle.textContent = "Pick a class, friend, or group to start chatting.";
          return;
        }
        const threadId = getThreadIdForTarget(target);
        const thread = getChatThread(threadId);
        let title = "Chat";
        let subtitle = "";
        if (target.type === "class") {
          const classInfo = getClassById(target.id);
          if (classInfo) {
            title = classInfo.name;
            const classmateCount = Array.isArray(classInfo.classmates) ? classInfo.classmates.length : 0;
            subtitle = classmateCount ? `${classInfo.room} · ${classmateCount} classmates` : `${classInfo.room} · Class chat`;
          } else {
            title = target.id;
            subtitle = "Class chat";
          }
        } else if (target.type === "dm") {
          const friend = getFriendByUsername(target.id);
          title = friend ? friend.name || friend.username || target.id : target.id;
          subtitle = "Direct message";
        } else if (target.type === "group") {
          const group = getGroupById(target.id);
          title = group ? group.name || "Group chat" : "Group chat";
          const memberCount = group && Array.isArray(group.members) ? group.members.length : 0;
          subtitle = memberCount ? `${memberCount} members` : "Group chat";
        }
        elements.chatTitle.textContent = title;
        elements.chatSubtitle.textContent = subtitle;
        if (!thread.length) {
          renderStudyEmpty(elements.chatMessages, "No messages yet.");
          return;
        }
        elements.chatMessages.innerHTML = "";
        thread.forEach((message) => {
          const bubble = document.createElement("div");
          const isMine = message.mine || message.sender === activeProfile.name;
          bubble.className = `message${isMine ? " mine" : ""}`;
          const sender = document.createElement("strong");
          const senderLink = document.createElement("a");
          senderLink.className = "link-button";
          senderLink.href = `/u/${encodeURIComponent(message.sender || "")}`;
          senderLink.textContent = message.sender || "Unknown";
          sender.appendChild(senderLink);
          const body = document.createElement("div");
          body.textContent = message.text || "";
          const timestamp = document.createElement("small");
          timestamp.textContent = message.time || "";
          bubble.appendChild(sender);
          bubble.appendChild(body);
          bubble.appendChild(timestamp);
          elements.chatMessages.appendChild(bubble);
        });
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      };

      const studyStorage = {
        get(key, fallback) {
          try {
            const scopedValue = localStorage.getItem(scopedStorageKey(key));
            if (scopedValue !== null) {
              return JSON.parse(scopedValue);
            }
            const legacyValue = localStorage.getItem(key);
            if (legacyValue !== null) {
              const parsed = JSON.parse(legacyValue);
              localStorage.setItem(scopedStorageKey(key), JSON.stringify(parsed));
              return parsed;
            }
            return fallback;
          } catch (error) {
            return fallback;
          }
        },
        set(key, value) {
          localStorage.setItem(scopedStorageKey(key), JSON.stringify(value));
        },
      };

      const studyKeys = {
        sets: "orbitStudySets",
        cards: "orbitStudyCards",
        progress: "orbitStudyProgress",
        activeSet: "orbitStudyActiveSet",
      };

      const studyData = {
        sets: [],
        cards: [],
        progress: {},
      };

      const studyState = {
        stage: "select",
        mode: "flashcards",
        workspaceView: "study",
        selectedSetId: null,
        flashcards: {
          index: 0,
          shuffle: false,
          shuffleSeed: 0,
          seen: new Set(),
          currentCardId: null,
        },
        practice: {
          seed: 0,
          queue: [],
          index: 0,
          current: null,
          type: "mixed",
          answered: false,
          lastResult: null,
          setId: null,
        },
        test: {
          seed: 0,
          active: false,
          index: 0,
          questions: [],
          answers: [],
          results: null,
          setId: null,
        },
        match: {
          seed: 0,
          terms: [],
          definitions: [],
          selectedTerm: null,
          selectedDefinition: null,
          matched: new Set(),
          timerId: null,
          startTime: null,
          elapsedMs: 0,
          setId: null,
        },
      };

      const studyImportDelimiters = {
        tab: "\t",
        semicolon: ";",
        comma: ",",
        pipe: "|",
        dash: " - ",
      };

      const makeStudyId = (prefix) => {
        if (window.crypto && crypto.randomUUID) {
          return `${prefix}-${crypto.randomUUID()}`;
        }
        return `${prefix}-${Date.now()}`;
      };

      const hashString = (value) => {
        let hash = 2166136261;
        for (let i = 0; i < value.length; i += 1) {
          hash ^= value.charCodeAt(i);
          hash = Math.imul(hash, 16777619);
        }
        return hash >>> 0;
      };

      const createSeededRng = (seed) => {
        let value = seed >>> 0;
        return () => {
          value = (value * 1664525 + 1013904223) >>> 0;
          return value / 4294967296;
        };
      };

      const shuffleWithSeed = (list, seed) => {
        const rng = createSeededRng(seed);
        const copy = [...list];
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(rng() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      };

      const getActiveSet = () => studyData.sets.find((set) => set.id === studyState.selectedSetId);

      const getCardsForSet = (setId) => studyData.cards.filter((card) => card.setId === setId);

      const getCardsForActiveSet = () => (studyState.selectedSetId ? getCardsForSet(studyState.selectedSetId) : []);

      const getSetVisibility = (set) => (set?.visibility === "public" ? "public" : "private");

      const buildStudySeed = () => {
        const username = String(activeProfile.name || "").trim().toLowerCase() || "user";
        const setDefinitions = [
          {
            title: "Biology Essentials",
            description: "Cells, energy, and genetics quick review.",
            visibility: "private",
            cards: [
              ["Mitosis", "Cell division that makes two identical daughter cells."],
              ["ATP", "Primary energy-carrying molecule in cells."],
              ["Osmosis", "Diffusion of water through a semipermeable membrane."],
              ["Ribosome", "Cell structure where proteins are synthesized."],
            ],
          },
          {
            title: "US History Key Terms",
            description: "Important events and ideas for upcoming quiz.",
            visibility: "public",
            cards: [
              ["Federalism", "Power shared between national and state governments."],
              ["New Deal", "Programs introduced to respond to the Great Depression."],
              ["Cold War", "Long geopolitical tension between the US and USSR."],
              ["Civil Rights Act", "Law banning discrimination in public life."],
            ],
          },
        ];
        const sets = setDefinitions.map((definition, index) => ({
          id: `seed-set-${username}-${index + 1}`,
          title: definition.title,
          description: definition.description,
          createdAt: new Date().toISOString(),
          visibility: definition.visibility,
        }));
        const cards = [];
        setDefinitions.forEach((definition, setIndex) => {
          definition.cards.forEach((pair, cardIndex) => {
            cards.push({
              id: `seed-card-${username}-${setIndex + 1}-${cardIndex + 1}`,
              setId: sets[setIndex].id,
              term: pair[0],
              definition: pair[1],
              starred: false,
            });
          });
        });
        const progress = {};
        cards.forEach((card) => {
          progress[card.id] = {
            cardId: card.id,
            seenCount: 0,
            correctCount: 0,
            wrongCount: 0,
            mastery: 0,
          };
        });
        return {
          sets,
          cards,
          progress,
          activeSet: sets[0]?.id || null,
        };
      };

      const loadStudyData = () => {
        studyData.sets = studyStorage.get(studyKeys.sets, []).map((set) => ({
          ...set,
          visibility: set.visibility === "public" ? "public" : "private",
        }));
        studyData.cards = studyStorage.get(studyKeys.cards, []);
        studyData.progress = studyStorage.get(studyKeys.progress, {});
        if (!studyData.sets.length && !studyData.cards.length) {
          const seeded = buildStudySeed();
          studyData.sets = seeded.sets;
          studyData.cards = seeded.cards;
          studyData.progress = seeded.progress;
          studyState.selectedSetId = seeded.activeSet;
          saveStudyData();
        }
        const savedSet = studyStorage.get(studyKeys.activeSet, null);
        const validSaved = savedSet && studyData.sets.some((set) => set.id === savedSet);
        studyState.selectedSetId = validSaved ? savedSet : studyData.sets[0]?.id || null;
      };

      const saveStudyData = () => {
        studyStorage.set(studyKeys.sets, studyData.sets);
        studyStorage.set(studyKeys.cards, studyData.cards);
        studyStorage.set(studyKeys.progress, studyData.progress);
        studyStorage.set(studyKeys.activeSet, studyState.selectedSetId);
      };

      const ensureProgress = (cardId) => {
        if (!studyData.progress[cardId]) {
          studyData.progress[cardId] = {
            cardId,
            seenCount: 0,
            correctCount: 0,
            wrongCount: 0,
            mastery: 0,
          };
        }
        return studyData.progress[cardId];
      };

      const updateProgress = (cardId, { seen = 0, correct = 0, wrong = 0 }) => {
        const progress = ensureProgress(cardId);
        progress.seenCount += seen;
        progress.correctCount += correct;
        progress.wrongCount += wrong;
        const total = progress.correctCount + progress.wrongCount;
        progress.mastery = total ? Math.min(1, progress.correctCount / total) : 0;
        saveStudyData();
      };

      const removeProgress = (cardId) => {
        delete studyData.progress[cardId];
      };

      const renderStudyEmpty = (container, message) => {
        container.innerHTML = "";
        const note = document.createElement("div");
        note.className = "study-empty";
        note.textContent = message;
        container.appendChild(note);
      };

      const setStudyStage = (stage) => {
        studyState.stage = stage;
        if (studyElements.selectStage) {
          studyElements.selectStage.classList.toggle("active", stage === "select");
        }
        if (studyElements.workspaceStage) {
          studyElements.workspaceStage.classList.toggle("active", stage === "workspace");
        }
      };

      const setStudyWorkspaceView = (view) => {
        studyState.workspaceView = view;
        if (studyElements.workspaceViewStudy) {
          studyElements.workspaceViewStudy.classList.toggle("active", view === "study");
        }
        if (studyElements.workspaceViewEdit) {
          studyElements.workspaceViewEdit.classList.toggle("active", view === "edit");
        }
        if (studyElements.editToggle) {
          studyElements.editToggle.textContent = view === "edit" ? "Back to study" : "Edit set";
        }
        updateStudyImportFormState();
      };

      const renderStudyWorkspaceHeader = () => {
        if (!studyElements.workspaceTitle || !studyElements.workspaceSubtitle) {
          return;
        }
        const activeSet = getActiveSet();
        if (!activeSet) {
          studyElements.workspaceTitle.textContent = "Study workspace";
          studyElements.workspaceSubtitle.textContent = "Choose a set to start studying.";
          return;
        }
        const cardCount = getCardsForSet(activeSet.id).length;
        const visibilityLabel = getSetVisibility(activeSet) === "public" ? "Public set" : "Private set";
        studyElements.workspaceTitle.textContent = activeSet.title;
        studyElements.workspaceSubtitle.textContent = `${cardCount} cards · ${visibilityLabel}`;
      };

      const renderStudySelectionActions = () => {
        if (!studyElements.continueSet) {
          return;
        }
        const activeSet = getActiveSet();
        if (!activeSet) {
          studyElements.continueSet.disabled = true;
          studyElements.continueSet.textContent = "Continue last set";
          return;
        }
        studyElements.continueSet.disabled = false;
        studyElements.continueSet.textContent = `Continue "${activeSet.title}"`;
      };

      const renderStudySelectLists = () => {
        if (!studyElements.publicList || !studyElements.privateList) {
          return;
        }
        const renderList = (container, sets, emptyMessage) => {
          container.innerHTML = "";
          if (!sets.length) {
            renderStudyEmpty(container, emptyMessage);
            return;
          }
          sets.forEach((set, index) => {
            const card = document.createElement("button");
            card.type = "button";
            card.className = `study-select-card${set.id === studyState.selectedSetId ? " active" : ""}`;
            card.style.animationDelay = `${index * 60}ms`;
            const header = document.createElement("div");
            header.className = "study-card-header";
            const title = document.createElement("strong");
            title.textContent = set.title;
            const chip = document.createElement("span");
            const visibility = getSetVisibility(set);
            chip.className = `study-chip ${visibility}`;
            chip.textContent = visibility === "public" ? "Public" : "Private";
            header.appendChild(title);
            header.appendChild(chip);
            const description = document.createElement("small");
            description.className = "muted";
            description.textContent = set.description || "No description";
            const meta = document.createElement("div");
            meta.className = "study-card-meta";
            const cardCount = getCardsForSet(set.id).length;
            meta.textContent = `${cardCount} cards`;
            card.appendChild(header);
            card.appendChild(description);
            card.appendChild(meta);
            card.addEventListener("click", () => setActiveSet(set.id));
            container.appendChild(card);
          });
        };
        const publicSets = studyData.sets.filter((set) => getSetVisibility(set) === "public");
        const privateSets = studyData.sets.filter((set) => getSetVisibility(set) !== "public");
        renderList(
          studyElements.publicList,
          publicSets,
          "No public sets yet. Mark one as public to share it here."
        );
        renderList(
          studyElements.privateList,
          privateSets,
          "No private sets yet. Create one to keep it just for you."
        );
        renderStudySelectionActions();
      };

      const setStudyImportStatus = (message, tone) => {
        if (!studyElements.importStatus) {
          return;
        }
        studyElements.importStatus.textContent = message || "";
        studyElements.importStatus.classList.toggle("success", tone === "success");
        studyElements.importStatus.classList.toggle("error", tone === "error");
      };

      const updateStudyImportCustomState = () => {
        if (!studyElements.importCustomWrap || !studyElements.importDelimiter) {
          return;
        }
        const isCustom = studyElements.importDelimiter.value === "custom";
        studyElements.importCustomWrap.hidden = !isCustom;
        if (studyElements.importCustom) {
          studyElements.importCustom.disabled = !isCustom;
        }
      };

      const getStudyImportDelimiter = () => {
        if (!studyElements.importDelimiter) {
          return { delimiter: "", fallback: "" };
        }
        const value = studyElements.importDelimiter.value;
        if (value === "custom") {
          const customValue = studyElements.importCustom ? studyElements.importCustom.value.trim() : "";
          const customDelimiter = customValue === "\\t" ? "\t" : customValue;
          return { delimiter: customDelimiter, fallback: "" };
        }
        if (value === "dash") {
          return { delimiter: studyImportDelimiters.dash, fallback: "-" };
        }
        const delimiter = studyImportDelimiters[value] || "";
        return { delimiter, fallback: "" };
      };

      const splitImportLine = (line, delimiter, fallbackDelimiter) => {
        if (!delimiter) {
          return null;
        }
        let usedDelimiter = delimiter;
        let index = line.indexOf(usedDelimiter);
        if (index === -1 && fallbackDelimiter) {
          usedDelimiter = fallbackDelimiter;
          index = line.indexOf(usedDelimiter);
        }
        if (index === -1) {
          return null;
        }
        const term = line.slice(0, index).trim();
        const definition = line.slice(index + usedDelimiter.length).trim();
        if (!term || !definition) {
          return null;
        }
        return { term, definition };
      };

      const parseStudyImportText = (rawText, delimiter, fallbackDelimiter) => {
        const lines = rawText.split(/\r?\n/);
        const cards = [];
        let skipped = 0;
        let total = 0;
        lines.forEach((line) => {
          if (!line || !line.trim()) {
            return;
          }
          total += 1;
          const parsed = splitImportLine(line, delimiter, fallbackDelimiter);
          if (!parsed) {
            skipped += 1;
            return;
          }
          cards.push(parsed);
        });
        return { cards, skipped, total };
      };

      const updateStudyImportFormState = () => {
        if (!studyElements.importForm) {
          return;
        }
        const hasSet = !!studyState.selectedSetId;
        studyElements.importForm.querySelectorAll("textarea, input, select, button").forEach((field) => {
          field.disabled = !hasSet;
        });
        if (!hasSet) {
          setStudyImportStatus("Select a set to import cards.", "");
        } else if (studyElements.importStatus?.textContent === "Select a set to import cards.") {
          setStudyImportStatus("", "");
        }
      };

      const resetStudyModes = () => {
        studyState.flashcards.index = 0;
        studyState.flashcards.seen = new Set();
        studyState.flashcards.currentCardId = null;
        studyState.practice.queue = [];
        studyState.practice.index = 0;
        studyState.practice.current = null;
        studyState.practice.answered = false;
        studyState.practice.lastResult = null;
        studyState.practice.setId = studyState.selectedSetId;
        studyState.test.active = false;
        studyState.test.questions = [];
        studyState.test.answers = [];
        studyState.test.results = null;
        studyState.test.index = 0;
        studyState.test.setId = studyState.selectedSetId;
        studyState.match.setId = studyState.selectedSetId;
      };

      const setActiveSet = (setId) => {
        studyState.selectedSetId = setId;
        setStudyStage("workspace");
        studyState.mode = "flashcards";
        setStudyWorkspaceView("study");
        resetStudyModes();
        setStudyImportStatus("", "");
        saveStudyData();
        renderStudySets();
        renderStudyCards();
        renderStudyMode();
        renderStudyWorkspaceHeader();
        startMatchGame();
      };

      const renderStudySets = () => {
        if (!studyElements.setList) {
          return;
        }
        studyElements.setList.innerHTML = "";
        if (!studyData.sets.length) {
          renderStudyEmpty(studyElements.setList, "No sets yet. Create one to begin.");
          renderStudySelectLists();
          renderStudyWorkspaceHeader();
          return;
        }
        studyData.sets.forEach((set) => {
          const card = document.createElement("div");
          card.className = `study-set-card${set.id === studyState.selectedSetId ? " active" : ""}`;
          const visibility = getSetVisibility(set);
          const header = document.createElement("div");
          header.className = "study-card-header";
          const title = document.createElement("strong");
          title.textContent = set.title;
          const chip = document.createElement("span");
          chip.className = `study-chip ${visibility}`;
          chip.textContent = visibility === "public" ? "Public" : "Private";
          header.appendChild(title);
          header.appendChild(chip);
          const description = document.createElement("small");
          description.className = "muted";
          description.textContent = set.description || "No description";
          const meta = document.createElement("div");
          meta.className = "study-card-meta";
          const cardCount = getCardsForSet(set.id).length;
          meta.textContent = `${cardCount} cards`;
          const actions = document.createElement("div");
          actions.className = "actions";
          const openButton = document.createElement("button");
          openButton.className = "ghost-button";
          openButton.textContent = set.id === studyState.selectedSetId ? "Selected" : "Open";
          openButton.addEventListener("click", (event) => {
            event.stopPropagation();
            setActiveSet(set.id);
          });
          const deleteButton = document.createElement("button");
          deleteButton.className = "ghost-button";
          deleteButton.textContent = "Delete";
          deleteButton.addEventListener("click", (event) => {
            event.stopPropagation();
            const ok = window.confirm("Delete this set and all its cards?");
            if (!ok) {
              return;
            }
            const cardIds = studyData.cards.filter((cardItem) => cardItem.setId === set.id).map((cardItem) => cardItem.id);
            studyData.cards = studyData.cards.filter((cardItem) => cardItem.setId !== set.id);
            cardIds.forEach((cardId) => removeProgress(cardId));
            studyData.sets = studyData.sets.filter((item) => item.id !== set.id);
            if (studyState.selectedSetId === set.id) {
              studyState.selectedSetId = studyData.sets[0]?.id || null;
            }
            resetStudyModes();
            saveStudyData();
            renderStudySets();
            renderStudyCards();
            renderStudyMode();
            startMatchGame();
          });
          actions.appendChild(openButton);
          actions.appendChild(deleteButton);
          card.appendChild(header);
          card.appendChild(description);
          card.appendChild(meta);
          card.appendChild(actions);
          card.addEventListener("click", () => setActiveSet(set.id));
          studyElements.setList.appendChild(card);
        });
        renderStudySelectLists();
        renderStudyWorkspaceHeader();
      };

      const renderStudyCards = () => {
        if (!studyElements.cardList) {
          return;
        }
        studyElements.cardList.innerHTML = "";
        const hasSet = !!studyState.selectedSetId;
        studyElements.cardForm.querySelectorAll("input, textarea, button").forEach((field) => {
          field.disabled = !hasSet;
        });
        updateStudyImportFormState();
        if (!hasSet) {
          renderStudyEmpty(studyElements.cardList, "Create or select a set to add cards.");
          renderStudySelectLists();
          renderStudyWorkspaceHeader();
          return;
        }
        const cards = getCardsForActiveSet();
        if (studyElements.testCount) {
          studyElements.testCount.max = Math.max(1, cards.length);
          if (Number(studyElements.testCount.value) > cards.length) {
            studyElements.testCount.value = Math.max(1, cards.length);
          }
        }
        if (!cards.length) {
          renderStudyEmpty(studyElements.cardList, "No cards yet. Add your first term.");
          renderStudySelectLists();
          renderStudyWorkspaceHeader();
          return;
        }
        cards.forEach((card) => {
          const progress = ensureProgress(card.id);
          const item = document.createElement("div");
          item.className = "study-card-item";
          const term = document.createElement("strong");
          term.textContent = card.term;
          const definition = document.createElement("small");
          definition.className = "muted";
          definition.textContent = card.definition;
          const meta = document.createElement("div");
          meta.className = "study-card-meta";
          const masteryPercent = Math.round(progress.mastery * 100);
          meta.textContent = `Seen ${progress.seenCount} · Mastery ${masteryPercent}%`;
          const actions = document.createElement("div");
          actions.className = "actions";
          const starButton = document.createElement("button");
          starButton.className = "ghost-button";
          starButton.textContent = card.starred ? "Unstar" : "Star";
          starButton.addEventListener("click", () => {
            card.starred = !card.starred;
            saveStudyData();
            renderStudyCards();
            renderFlashcardsMode();
          });
          const removeButton = document.createElement("button");
          removeButton.className = "ghost-button";
          removeButton.textContent = "Remove";
          removeButton.addEventListener("click", () => {
            studyData.cards = studyData.cards.filter((entry) => entry.id !== card.id);
            removeProgress(card.id);
            saveStudyData();
            renderStudyCards();
            renderStudyMode();
          });
          actions.appendChild(starButton);
          actions.appendChild(removeButton);
          item.appendChild(term);
          item.appendChild(definition);
          item.appendChild(meta);
          item.appendChild(actions);
          studyElements.cardList.appendChild(item);
        });
        renderStudySelectLists();
        renderStudyWorkspaceHeader();
      };

      const renderStudyMode = () => {
        if (!studyElements.modeToggle) {
          return;
        }
        studyElements.modeToggle.querySelectorAll("button").forEach((button) => {
          button.classList.toggle("active", button.dataset.studyMode === studyState.mode);
        });
        document.querySelectorAll("[data-study-panel]").forEach((panel) => {
          panel.classList.toggle("active", panel.dataset.studyPanel === studyState.mode);
        });
        if (studyState.mode === "flashcards") {
          renderFlashcardsMode();
        } else if (studyState.mode === "learn") {
          renderPracticeMode();
        } else if (studyState.mode === "test") {
          renderTestMode();
        } else if (studyState.mode === "match") {
          renderMatchMode();
        }
      };

      const getFlashcardOrder = (cards) => {
        if (!studyState.flashcards.shuffle) {
          return cards;
        }
        const seed = hashString(`${studyState.selectedSetId}|flash|${studyState.flashcards.shuffleSeed}`);
        return shuffleWithSeed(cards, seed);
      };

      // Flashcards mode: term -> flip -> definition, with shuffle and star.
      const renderFlashcardsMode = () => {
        if (!studyElements.flashcard) {
          return;
        }
        const cards = getCardsForActiveSet();
        if (!studyState.selectedSetId || !cards.length) {
          studyElements.flashcard.classList.remove("flipped");
          studyElements.flashFront.textContent = "Add cards to start studying.";
          studyElements.flashBack.textContent = "";
          studyElements.flashProgress.textContent = "Card 0 of 0";
          studyElements.flashShuffle.checked = false;
          studyElements.flashStar.textContent = "Star";
          studyElements.flashPrev.disabled = true;
          studyElements.flashNext.disabled = true;
          studyElements.flashStar.disabled = true;
          return;
        }
        const order = getFlashcardOrder(cards);
        if (studyState.flashcards.index >= order.length) {
          studyState.flashcards.index = 0;
        }
        const card = order[studyState.flashcards.index];
        studyState.flashcards.currentCardId = card.id;
        studyElements.flashcard.classList.remove("flipped");
        studyElements.flashFront.textContent = card.term;
        studyElements.flashBack.textContent = card.definition;
        studyElements.flashProgress.textContent = `Card ${studyState.flashcards.index + 1} of ${order.length}`;
        studyElements.flashShuffle.checked = studyState.flashcards.shuffle;
        studyElements.flashStar.textContent = card.starred ? "Unstar" : "Star";
        studyElements.flashPrev.disabled = order.length < 2;
        studyElements.flashNext.disabled = order.length < 2;
        studyElements.flashStar.disabled = false;
      };

      const handleFlashcardFlip = () => {
        if (!studyState.flashcards.currentCardId) {
          return;
        }
        studyElements.flashcard.classList.toggle("flipped");
        if (studyElements.flashcard.classList.contains("flipped")) {
          const cardId = studyState.flashcards.currentCardId;
          if (!studyState.flashcards.seen.has(cardId)) {
            studyState.flashcards.seen.add(cardId);
            updateProgress(cardId, { seen: 1 });
            renderStudyCards();
          }
        }
      };

      const buildPracticeQueue = (cards) => {
        const weighted = [];
        cards.forEach((card) => {
          const progress = ensureProgress(card.id);
          const penalty = Math.max(0, progress.wrongCount - progress.correctCount);
          const repeats = 1 + Math.min(3, penalty);
          for (let i = 0; i < repeats; i += 1) {
            weighted.push(card.id);
          }
        });
        const seed = hashString(`${studyState.selectedSetId}|practice|${studyState.practice.seed}`);
        return shuffleWithSeed(weighted, seed);
      };

      const buildOptions = (card, cards, field, seedSalt) => {
        const others = cards.filter((item) => item.id !== card.id).map((item) => item[field]);
        const baseSeed = hashString(`${card.id}|${field}|${seedSalt}`);
        const shuffled = shuffleWithSeed(others, baseSeed);
        const selection = shuffled.slice(0, 3);
        const options = shuffleWithSeed([card[field], ...selection], baseSeed + 1);
        return options;
      };

      const normalizeAnswer = (value) => value.toLowerCase().trim();

      // Practice / Learn mode: mixed multiple-choice and written, with repeat bias on mistakes.
      const renderPracticeMode = () => {
        const container = studyElements.practiceCard;
        container.innerHTML = "";
        const cards = getCardsForActiveSet();
        if (!studyState.selectedSetId) {
          renderStudyEmpty(container, "Select or create a set to start practicing.");
          return;
        }
        if (!cards.length) {
          renderStudyEmpty(container, "Add cards to start practicing.");
          return;
        }
        if (studyState.practice.setId !== studyState.selectedSetId || !studyState.practice.queue.length) {
          studyState.practice.queue = buildPracticeQueue(cards);
          studyState.practice.index = 0;
          studyState.practice.answered = false;
          studyState.practice.lastResult = null;
          studyState.practice.setId = studyState.selectedSetId;
        }
        if (!studyState.practice.queue.length) {
          renderStudyEmpty(container, "Add more cards to begin practice.");
          return;
        }
        if (studyState.practice.index >= studyState.practice.queue.length) {
          studyState.practice.seed += 1;
          studyState.practice.queue = buildPracticeQueue(cards);
          studyState.practice.index = 0;
        }
        const cardId = studyState.practice.queue[studyState.practice.index];
        const card = cards.find((item) => item.id === cardId);
        if (!card) {
          renderStudyEmpty(container, "Unable to find this card.");
          return;
        }
        const type =
          studyState.practice.type === "mixed"
            ? studyState.practice.index % 2 === 0
              ? "mc"
              : "written"
            : studyState.practice.type;
        let question = null;
        if (type === "mc") {
          const options = buildOptions(card, cards, "definition", "practice");
          if (options.length < 2) {
            question = {
              type: "written",
              prompt: card.definition,
              answer: card.term,
              card,
              label: "Type the term that matches:",
            };
          } else {
            question = {
              type: "mc",
              prompt: `What is the definition of "${card.term}"?`,
              answer: card.definition,
              options,
              card,
            };
          }
        } else {
          question = {
            type: "written",
            prompt: card.definition,
            answer: card.term,
            card,
            label: "Type the term that matches:",
          };
        }
        studyState.practice.current = question;

        const header = document.createElement("div");
        const counter = document.createElement("p");
        counter.className = "muted";
        counter.textContent = `Card ${studyState.practice.index + 1} of ${studyState.practice.queue.length}`;
        const prompt = document.createElement("div");
        const promptText = document.createElement("strong");
        promptText.textContent = question.type === "mc" ? question.prompt : question.label;
        prompt.appendChild(promptText);
        header.appendChild(counter);
        header.appendChild(prompt);
        container.appendChild(header);

        if (question.type === "mc") {
          const optionsWrap = document.createElement("div");
          optionsWrap.className = "quiz-options";
          question.options.forEach((option) => {
            const button = document.createElement("button");
            button.textContent = option;
            button.addEventListener("click", () => {
              if (studyState.practice.answered) {
                return;
              }
              handlePracticeAnswer(question, option);
            });
            optionsWrap.appendChild(button);
          });
          container.appendChild(optionsWrap);
        } else {
          const definition = document.createElement("p");
          definition.textContent = question.prompt;
          container.appendChild(definition);
          const form = document.createElement("form");
          form.className = "study-form";
          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = "Type the term";
          input.value = studyState.practice.answered ? studyState.practice.lastResult?.answer || "" : "";
          const submit = document.createElement("button");
          submit.className = "primary-button";
          submit.type = "submit";
          submit.textContent = "Check answer";
          form.appendChild(input);
          form.appendChild(submit);
          form.addEventListener("submit", (event) => {
            event.preventDefault();
            if (studyState.practice.answered) {
              return;
            }
            handlePracticeAnswer(question, input.value);
          });
          container.appendChild(form);
        }

        if (studyState.practice.answered) {
          const feedback = document.createElement("div");
          feedback.className = "study-card-meta";
          feedback.textContent = studyState.practice.lastResult.correct
            ? "Correct."
            : `Correct answer: ${question.answer}`;
          container.appendChild(feedback);
          const nextButton = document.createElement("button");
          nextButton.className = "primary-button";
          nextButton.type = "button";
          nextButton.textContent = "Next";
          nextButton.addEventListener("click", () => {
            studyState.practice.index += 1;
            studyState.practice.answered = false;
            studyState.practice.lastResult = null;
            renderPracticeMode();
          });
          container.appendChild(nextButton);
        }
      };

      const handlePracticeAnswer = (question, answer) => {
        const normalized = normalizeAnswer(answer);
        const correct = normalized === normalizeAnswer(question.answer);
        updateProgress(question.card.id, { seen: 1, correct: correct ? 1 : 0, wrong: correct ? 0 : 1 });
        if (!correct) {
          studyState.practice.queue.push(question.card.id);
          studyState.practice.queue.push(question.card.id);
        }
        studyState.practice.answered = true;
        studyState.practice.lastResult = { correct, answer };
        renderPracticeMode();
        renderStudyCards();
      };

      const buildTestQuestions = (cards, count) => {
        const seed = hashString(`${studyState.selectedSetId}|test|${studyState.test.seed}`);
        const order = shuffleWithSeed(cards, seed).slice(0, count);
        return order.map((card, index) => {
          const type = index % 2 === 0 ? "mc" : "written";
          if (type === "mc") {
            const options = buildOptions(card, cards, "definition", `test-${index}`);
            if (options.length < 2) {
              return {
                type: "written",
                prompt: card.definition,
                answer: card.term,
                card,
                label: "Type the term that matches:",
              };
            }
            return {
              type: "mc",
              prompt: `What is the definition of "${card.term}"?`,
              answer: card.definition,
              options,
              card,
            };
          }
          return {
            type: "written",
            prompt: card.definition,
            answer: card.term,
            card,
            label: "Type the term that matches:",
          };
        });
      };

      // Test mode: mixed question types with scoring and retry missed only.
      const renderTestMode = () => {
        const container = studyElements.testCard;
        container.innerHTML = "";
        const cards = getCardsForActiveSet();
        if (!studyState.selectedSetId) {
          renderStudyEmpty(container, "Select or create a set to start a test.");
          return;
        }
        if (!cards.length) {
          renderStudyEmpty(container, "Add cards to start a test.");
          return;
        }
        if (!studyState.test.active && studyState.test.results) {
          const summary = document.createElement("div");
          const heading = document.createElement("h3");
          heading.textContent = "Test results";
          const score = document.createElement("p");
          score.className = "muted";
          score.textContent = `Score: ${studyState.test.results.correct} / ${studyState.test.results.total}`;
          summary.appendChild(heading);
          summary.appendChild(score);
          container.appendChild(summary);
          if (studyState.test.results.missed.length) {
            const missedList = document.createElement("div");
            missedList.className = "quiz-options";
            studyState.test.results.missed.forEach((missed) => {
              const item = document.createElement("div");
              item.className = "study-card-item";
              const promptText = document.createElement("strong");
              promptText.textContent = missed.prompt;
              const yourAnswer = document.createElement("small");
              yourAnswer.className = "muted";
              yourAnswer.textContent = `Your answer: ${missed.answer || "N/A"}`;
              const correctAnswer = document.createElement("small");
              correctAnswer.className = "muted";
              correctAnswer.textContent = `Correct answer: ${missed.correctAnswer}`;
              item.appendChild(promptText);
              item.appendChild(yourAnswer);
              item.appendChild(correctAnswer);
              missedList.appendChild(item);
            });
            container.appendChild(missedList);
            const retryButton = document.createElement("button");
            retryButton.className = "primary-button";
            retryButton.type = "button";
            retryButton.textContent = "Retry missed only";
            retryButton.addEventListener("click", () => {
              const missedCards = studyState.test.results.missed.map((item) => item.cardId);
              startTest(missedCards);
            });
            container.appendChild(retryButton);
          }
          const restart = document.createElement("button");
          restart.className = "ghost-button";
          restart.type = "button";
          restart.textContent = "Start new test";
          restart.addEventListener("click", () => {
            studyState.test.results = null;
            renderTestMode();
          });
          container.appendChild(restart);
          return;
        }

        if (!studyState.test.active) {
          const intro = document.createElement("p");
          intro.className = "muted";
          intro.textContent = "Choose a question count and start a test.";
          container.appendChild(intro);
          return;
        }

        const question = studyState.test.questions[studyState.test.index];
        if (!question) {
          renderStudyEmpty(container, "Unable to load this question.");
          return;
        }
        const counter = document.createElement("p");
        counter.className = "muted";
        counter.textContent = `Question ${studyState.test.index + 1} of ${studyState.test.questions.length}`;
        container.appendChild(counter);
        const prompt = document.createElement("div");
        const promptText = document.createElement("strong");
        promptText.textContent = question.type === "mc" ? question.prompt : question.label;
        prompt.appendChild(promptText);
        container.appendChild(prompt);

        if (question.type === "mc") {
          const optionsWrap = document.createElement("div");
          optionsWrap.className = "quiz-options";
          question.options.forEach((option) => {
            const button = document.createElement("button");
            button.textContent = option;
            button.addEventListener("click", () => {
              if (studyState.test.active === false) {
                return;
              }
              handleTestAnswer(question, option);
            });
            optionsWrap.appendChild(button);
          });
          container.appendChild(optionsWrap);
        } else {
          const definition = document.createElement("p");
          definition.textContent = question.prompt;
          container.appendChild(definition);
          const form = document.createElement("form");
          form.className = "study-form";
          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = "Type the term";
          const submit = document.createElement("button");
          submit.className = "primary-button";
          submit.type = "submit";
          submit.textContent = "Submit";
          form.appendChild(input);
          form.appendChild(submit);
          form.addEventListener("submit", (event) => {
            event.preventDefault();
            handleTestAnswer(question, input.value);
          });
          container.appendChild(form);
        }
      };

      const startTest = (cardsOverride = null) => {
        const cards = cardsOverride
          ? studyData.cards.filter((card) => cardsOverride.includes(card.id))
          : getCardsForActiveSet();
        if (!cards.length) {
          return;
        }
        const requested = Number(studyElements.testCount.value) || cards.length;
        const count = Math.max(1, Math.min(cards.length, requested));
        studyElements.testCount.value = count;
        studyState.test.seed += 1;
        studyState.test.questions = buildTestQuestions(cards, count);
        studyState.test.answers = [];
        studyState.test.index = 0;
        studyState.test.active = true;
        studyState.test.results = null;
        studyState.test.setId = studyState.selectedSetId;
        renderTestMode();
      };

      const handleTestAnswer = (question, answer) => {
        const correct = normalizeAnswer(answer) === normalizeAnswer(question.answer);
        studyState.test.answers.push({
          cardId: question.card.id,
          prompt: question.type === "mc" ? question.prompt : `${question.label} ${question.prompt}`,
          answer,
          correctAnswer: question.answer,
          correct,
        });
        updateProgress(question.card.id, { seen: 1, correct: correct ? 1 : 0, wrong: correct ? 0 : 1 });
        if (studyState.test.index + 1 >= studyState.test.questions.length) {
          const correctCount = studyState.test.answers.filter((item) => item.correct).length;
          const missed = studyState.test.answers.filter((item) => !item.correct);
          studyState.test.results = {
            total: studyState.test.questions.length,
            correct: correctCount,
            missed,
          };
          studyState.test.active = false;
        } else {
          studyState.test.index += 1;
        }
        renderTestMode();
        renderStudyCards();
      };

      const formatElapsed = (ms) => {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
        const seconds = String(totalSeconds % 60).padStart(2, "0");
        return `${minutes}:${seconds}`;
      };

      const updateMatchTimer = () => {
        if (!studyState.match.startTime) {
          return;
        }
        const now = Date.now();
        studyState.match.elapsedMs = now - studyState.match.startTime;
        studyElements.matchTimer.textContent = formatElapsed(studyState.match.elapsedMs);
      };

      const startMatchGame = () => {
        const cards = getCardsForActiveSet();
        if (studyState.match.timerId) {
          clearInterval(studyState.match.timerId);
        }
        if (!studyState.selectedSetId || !cards.length) {
          studyState.match.terms = [];
          studyState.match.definitions = [];
          studyState.match.matched = new Set();
          studyState.match.selectedTerm = null;
          studyState.match.selectedDefinition = null;
          studyElements.matchTimer.textContent = "00:00";
          renderMatchMode();
          return;
        }
        studyState.match.seed += 1;
        const baseSeed = hashString(`${studyState.selectedSetId}|match|${studyState.match.seed}`);
        studyState.match.terms = shuffleWithSeed(
          cards.map((card) => ({ id: card.id, text: card.term })),
          baseSeed
        );
        studyState.match.definitions = shuffleWithSeed(
          cards.map((card) => ({ id: card.id, text: card.definition })),
          baseSeed + 1
        );
        studyState.match.matched = new Set();
        studyState.match.selectedTerm = null;
        studyState.match.selectedDefinition = null;
        studyState.match.startTime = Date.now();
        studyState.match.elapsedMs = 0;
        studyElements.matchTimer.textContent = "00:00";
        studyState.match.timerId = setInterval(updateMatchTimer, 1000);
        renderMatchMode();
      };

      // Match mode: timed term/definition pairing with deterministic order.
      const renderMatchMode = () => {
        const cards = getCardsForActiveSet();
        if (!studyState.selectedSetId || !cards.length) {
          renderStudyEmpty(studyElements.matchTerms, "Add cards to start matching.");
          studyElements.matchDefinitions.innerHTML = "";
          studyElements.matchStatus.textContent = "Match terms with definitions.";
          return;
        }
        studyElements.matchTerms.innerHTML = "";
        studyElements.matchDefinitions.innerHTML = "";
        studyElements.matchStatus.textContent = `Matched ${studyState.match.matched.size} of ${cards.length}`;

        const buildItem = (item, type) => {
          const button = document.createElement("button");
          button.className = "matching-item";
          button.textContent = item.text;
          if (studyState.match.matched.has(item.id)) {
            button.classList.add("matched");
          }
          if (type === "term" && studyState.match.selectedTerm === item.id) {
            button.classList.add("selected");
          }
          if (type === "definition" && studyState.match.selectedDefinition === item.id) {
            button.classList.add("selected");
          }
          button.addEventListener("click", () => handleMatchSelection(type, item.id));
          return button;
        };

        studyState.match.terms.forEach((term) => {
          studyElements.matchTerms.appendChild(buildItem(term, "term"));
        });
        studyState.match.definitions.forEach((definition) => {
          studyElements.matchDefinitions.appendChild(buildItem(definition, "definition"));
        });

        if (studyState.match.matched.size === cards.length && cards.length > 0) {
          if (studyState.match.timerId) {
            clearInterval(studyState.match.timerId);
            studyState.match.timerId = null;
          }
          studyElements.matchStatus.textContent = `Finished in ${formatElapsed(studyState.match.elapsedMs)}`;
        }
      };

      const handleMatchSelection = (type, id) => {
        if (studyState.match.matched.has(id)) {
          return;
        }
        if (type === "term") {
          studyState.match.selectedTerm = id;
        } else {
          studyState.match.selectedDefinition = id;
        }
        if (studyState.match.selectedTerm && studyState.match.selectedDefinition) {
          const isMatch = studyState.match.selectedTerm === studyState.match.selectedDefinition;
          if (isMatch) {
            studyState.match.matched.add(studyState.match.selectedTerm);
            updateProgress(studyState.match.selectedTerm, { seen: 1, correct: 1 });
          } else {
            updateProgress(studyState.match.selectedTerm, { seen: 1, wrong: 1 });
            updateProgress(studyState.match.selectedDefinition, { seen: 1, wrong: 1 });
          }
          const resetSelection = () => {
            studyState.match.selectedTerm = null;
            studyState.match.selectedDefinition = null;
            renderMatchMode();
            renderStudyCards();
          };
          if (isMatch) {
            resetSelection();
          } else {
            setTimeout(resetSelection, 400);
          }
        } else {
          renderMatchMode();
        }
      };

      const initStudySystem = () => {
        if (!studyElements.root) {
          return;
        }
        loadStudyData();
        setStudyStage("select");
        renderStudySets();
        renderStudyCards();
        renderStudyMode();
        startMatchGame();

        if (studyElements.enterWorkspace) {
          studyElements.enterWorkspace.addEventListener("click", () => {
            setStudyStage("workspace");
            setStudyWorkspaceView("edit");
            studyElements.setTitle?.focus();
          });
        }

        if (studyElements.backSelect) {
          studyElements.backSelect.addEventListener("click", () => {
            setStudyStage("select");
          });
        }

        if (studyElements.editToggle) {
          studyElements.editToggle.addEventListener("click", () => {
            const nextView = studyState.workspaceView === "study" ? "edit" : "study";
            setStudyWorkspaceView(nextView);
            if (nextView === "study") {
              renderStudyMode();
            }
          });
        }

        if (studyElements.continueSet) {
          studyElements.continueSet.addEventListener("click", () => {
            if (studyState.selectedSetId) {
              setActiveSet(studyState.selectedSetId);
            } else {
              setStudyStage("workspace");
              setStudyWorkspaceView("edit");
            }
          });
        }

        studyElements.setForm.addEventListener("submit", (event) => {
          event.preventDefault();
          const title = studyElements.setTitle.value.trim();
          if (!title) {
            return;
          }
          const description = studyElements.setDescription.value.trim();
          const newSet = {
            id: makeStudyId("set"),
            title,
            description,
            createdAt: new Date().toISOString(),
            visibility: studyElements.setPublic?.checked ? "public" : "private",
          };
          studyData.sets.unshift(newSet);
          studyState.selectedSetId = newSet.id;
          resetStudyModes();
          saveStudyData();
          studyElements.setForm.reset();
          renderStudySets();
          renderStudyCards();
          renderStudyMode();
          startMatchGame();
        });

        studyElements.cardForm.addEventListener("submit", (event) => {
          event.preventDefault();
          if (!studyState.selectedSetId) {
            return;
          }
          const term = studyElements.cardTerm.value.trim();
          const definition = studyElements.cardDefinition.value.trim();
          if (!term || !definition) {
            return;
          }
          const newCard = {
            id: makeStudyId("card"),
            setId: studyState.selectedSetId,
            term,
            definition,
            starred: false,
          };
          studyData.cards.unshift(newCard);
          ensureProgress(newCard.id);
          saveStudyData();
          studyElements.cardForm.reset();
          renderStudyCards();
          renderStudyMode();
          startMatchGame();
        });

        if (studyElements.importDelimiter) {
          studyElements.importDelimiter.addEventListener("change", () => {
            updateStudyImportCustomState();
            setStudyImportStatus("", "");
          });
          updateStudyImportCustomState();
        }

        if (studyElements.importForm) {
          studyElements.importForm.addEventListener("submit", (event) => {
            event.preventDefault();
            if (!studyState.selectedSetId) {
              setStudyImportStatus("Select a set to import cards.", "error");
              return;
            }
            const rawText = studyElements.importText ? studyElements.importText.value.trim() : "";
            if (!rawText) {
              setStudyImportStatus("Paste your terms and definitions first.", "error");
              return;
            }
            const { delimiter, fallback } = getStudyImportDelimiter();
            if (!delimiter) {
              setStudyImportStatus("Choose a delimiter to split term and definition.", "error");
              return;
            }
            const { cards, skipped, total } = parseStudyImportText(rawText, delimiter, fallback);
            if (!cards.length) {
              setStudyImportStatus("No valid cards found. Check the delimiter.", "error");
              return;
            }
            const newCards = cards.map((entry) => ({
              id: makeStudyId("card"),
              setId: studyState.selectedSetId,
              term: entry.term,
              definition: entry.definition,
              starred: false,
            }));
            newCards.forEach((card) => ensureProgress(card.id));
            studyData.cards = [...newCards, ...studyData.cards];
            saveStudyData();
            if (studyElements.importText) {
              studyElements.importText.value = "";
            }
            const cardLabel = newCards.length === 1 ? "card" : "cards";
            const skippedLabel = skipped ? ` Skipped ${skipped} of ${total} lines.` : "";
            setStudyImportStatus(`Imported ${newCards.length} ${cardLabel}.${skippedLabel}`, "success");
            renderStudyCards();
            renderStudyMode();
            startMatchGame();
          });
        }

        studyElements.modeToggle.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            studyState.mode = button.dataset.studyMode;
            renderStudyMode();
          });
        });

        studyElements.flashcard.addEventListener("click", handleFlashcardFlip);
        studyElements.flashPrev.addEventListener("click", () => {
          const cards = getCardsForActiveSet();
          if (!cards.length) {
            return;
          }
          const order = getFlashcardOrder(cards);
          studyState.flashcards.index = (studyState.flashcards.index - 1 + order.length) % order.length;
          renderFlashcardsMode();
        });
        studyElements.flashNext.addEventListener("click", () => {
          const cards = getCardsForActiveSet();
          if (!cards.length) {
            return;
          }
          const order = getFlashcardOrder(cards);
          studyState.flashcards.index = (studyState.flashcards.index + 1) % order.length;
          renderFlashcardsMode();
        });
        studyElements.flashShuffle.addEventListener("change", (event) => {
          studyState.flashcards.shuffle = event.target.checked;
          studyState.flashcards.shuffleSeed += 1;
          studyState.flashcards.index = 0;
          renderFlashcardsMode();
        });
        studyElements.flashStar.addEventListener("click", () => {
          const cardId = studyState.flashcards.currentCardId;
          if (!cardId) {
            return;
          }
          const card = studyData.cards.find((item) => item.id === cardId);
          if (!card) {
            return;
          }
          card.starred = !card.starred;
          saveStudyData();
          renderStudyCards();
          renderFlashcardsMode();
        });

        studyElements.practiceTypeToggle.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            studyElements.practiceTypeToggle.querySelectorAll("button").forEach((btn) => btn.classList.remove("active"));
            button.classList.add("active");
            studyState.practice.type = button.dataset.practiceType;
            studyState.practice.queue = [];
            studyState.practice.index = 0;
            studyState.practice.answered = false;
            renderPracticeMode();
          });
        });

        studyElements.testStart.addEventListener("click", () => startTest());
        studyElements.matchReset.addEventListener("click", startMatchGame);
      };

      const loadScheduleExtras = () => {
        const stored = readScopedOrLegacy("orbitScheduleExtras", []);
        state.scheduleExtras = Array.isArray(stored) ? stored : [];
      };

      const saveScheduleExtras = () => {
        storage.set(scopedStorageKey("orbitScheduleExtras"), state.scheduleExtras);
      };

      const addScheduleItem = (event) => {
        event.preventDefault();
        const newItem = {
          id: `event-${Date.now()}`,
          day: elements.scheduleDay.value,
          title: elements.scheduleTitle.value.trim(),
          start: elements.scheduleStart.value,
          end: elements.scheduleEnd.value,
          location: elements.scheduleLocation.value.trim(),
          scheduleType: elements.scheduleType.value,
        };
        state.scheduleExtras.push(newItem);
        saveScheduleExtras();
        elements.scheduleForm.reset();
        renderSchedule();
      };

      const removeScheduleItem = (id) => {
        state.scheduleExtras = state.scheduleExtras.filter((item) => item.id !== id);
        saveScheduleExtras();
        state.selectedClass = null;
        renderSchedule();
      };

      const loadTodos = () => {
        const stored = readScopedOrLegacy("orbitTodos", []);
        if (Array.isArray(stored) && stored.length) {
          state.todos = stored;
        } else {
          state.todos = buildTodosSeed();
          storage.set(scopedStorageKey("orbitTodos"), state.todos);
        }
        pruneTodos();
      };

      const saveTodos = () => {
        storage.set(scopedStorageKey("orbitTodos"), state.todos);
      };

      const isPastDueDate = (dueDate) => {
        if (!dueDate) {
          return false;
        }
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const due = new Date(`${dueDate}T00:00:00`);
        return due < today;
      };

      const pruneTodos = () => {
        const before = state.todos.length;
        state.todos = state.todos.filter((todo) => !(todo.completed && isPastDueDate(todo.dueDate)));
        if (state.todos.length !== before) {
          saveTodos();
        }
      };

      const getDueStatus = (dueDate, completed) => {
        if (!dueDate || completed) {
          return "none";
        }
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const due = new Date(`${dueDate}T00:00:00`);
        const diff = due - today;
        const oneDay = 24 * 60 * 60 * 1000;
        if (diff < 0) {
          return "overdue";
        }
        if (diff === 0) {
          return "today";
        }
        if (diff <= oneDay * 3) {
          return "upcoming";
        }
        return "later";
      };

      const formatDate = (dateString) => {
        if (!dateString) {
          return "No due date";
        }
        const date = new Date(`${dateString}T00:00:00`);
        return date.toLocaleDateString(undefined, {
          month: "short",
          day: "numeric",
        });
      };

      const renderTodoList = () => {
        pruneTodos();
        const classFilter = elements.filterClass.value;
        const statusFilter = elements.filterStatus.value;
        const dueFilter = elements.filterDue.value;

        const filtered = state.todos.filter((todo) => {
          if (classFilter !== "all" && todo.classId !== classFilter) {
            return false;
          }
          if (statusFilter === "active" && todo.completed) {
            return false;
          }
          if (statusFilter === "completed" && !todo.completed) {
            return false;
          }
          const dueStatus = getDueStatus(todo.dueDate, todo.completed);
          if (dueFilter === "overdue" && dueStatus !== "overdue") {
            return false;
          }
          if (dueFilter === "today" && dueStatus !== "today") {
            return false;
          }
          if (dueFilter === "upcoming" && dueStatus !== "upcoming") {
            return false;
          }
          return true;
        });

        elements.todoList.innerHTML = "";
        if (!filtered.length) {
          elements.todoList.innerHTML = '<p class="muted">No assignments match the filters.</p>';
        }

        filtered.forEach((todo) => {
          const classInfo = getClassById(todo.classId);
          const className = classInfo ? classInfo.name : "Unknown class";
          const dueStatus = getDueStatus(todo.dueDate, todo.completed);
          const item = document.createElement("div");
          item.className = `todo-item ${todo.completed ? "completed" : ""} ${dueStatus}`;
          item.innerHTML = `
            <strong>${todo.title}</strong>
            <div class="todo-meta">
              <span>${className}</span>
              <span>${formatDate(todo.dueDate)}</span>
            </div>
            <div>${todo.notes ? todo.notes : ""}</div>
            <div class="todo-actions">
              <button data-todo-id="${todo.id}">${todo.completed ? "Undo" : "Mark complete"}</button>
              <span class="muted">${dueStatus === "overdue" ? "Overdue" : dueStatus === "today" ? "Due today" : dueStatus === "upcoming" ? "Due soon" : ""}</span>
            </div>
          `;
          item.querySelector("button").addEventListener("click", () => toggleTodo(todo.id));
          elements.todoList.appendChild(item);
        });

        const activeCount = state.todos.filter((todo) => !todo.completed).length;
        elements.todoCount.textContent = `${activeCount} active assignments`;
      };

      const toggleTodo = (id) => {
        state.todos = state.todos.map((todo) =>
          todo.id === id ? { ...todo, completed: !todo.completed } : todo
        );
        saveTodos();
        renderTodoList();
      };

      const addTodo = (event) => {
        event.preventDefault();
        const classId = elements.todoClass.value;
        if (!classId) {
          return;
        }
        const newTodo = {
          id: `todo-${Date.now()}`,
          classId,
          title: elements.todoTitle.value.trim(),
          dueDate: elements.todoDue.value,
          notes: elements.todoNotes.value.trim(),
          completed: false,
        };
        state.todos.unshift(newTodo);
        saveTodos();
        elements.todoForm.reset();
        renderTodoList();
      };

      const renderTodoSelectors = () => {
        const classOptions = mockData.classes.map((item) => ({ value: item.id, label: item.name }));
        const hasClasses = classOptions.length > 0;
        if (!hasClasses) {
          elements.todoClass.innerHTML = '<option value="">Add classes in Schedule first</option>';
          elements.filterClass.innerHTML = '<option value="all">All classes</option>';
        } else {
          elements.todoClass.innerHTML = classOptions
            .map((item) => `<option value="${item.value}">${item.label}</option>`)
            .join("");
          elements.filterClass.innerHTML =
            '<option value="all">All classes</option>' +
            classOptions.map((item) => `<option value="${item.value}">${item.label}</option>`).join("");
        }
        if (elements.todoForm) {
          elements.todoForm.querySelectorAll("input, select, button, textarea").forEach((field) => {
            field.disabled = !hasClasses;
          });
        }
      };

      const loadSettings = async () => {
        const stored = await settingsStorage.load();
        mockData.settings.forEach((setting) => {
          state.settings[setting.id] = stored[setting.id] ?? setting.default;
        });
      };

      const saveSettings = async () => {
        await settingsStorage.save(state.settings);
      };

      const applySettings = () => {
        document.body.classList.toggle("midnight", !!state.settings.midnight);
        document.body.classList.toggle("reduce-motion", !!state.settings.reduceMotion);
      };

      const renderSettings = () => {
        elements.settingsList.innerHTML = "";
        mockData.settings.forEach((setting) => {
          const row = document.createElement("label");
          row.className = "toggle";
          row.innerHTML = `
            <span>${setting.label}</span>
            <input type="checkbox" data-setting="${setting.id}" ${state.settings[setting.id] ? "checked" : ""} />
          `;
          row.querySelector("input").addEventListener("change", async (event) => {
            state.settings[setting.id] = event.target.checked;
            await saveSettings();
            applySettings();
          });
          elements.settingsList.appendChild(row);
        });
      };

      const getFriendScheduleClassById = (id) =>
        friendsPageState.classes.find((item) => item && item.id === id);

      const getFriendSearchQuery = () => {
        if (!elements.friendSearch) {
          return "";
        }
        return elements.friendSearch.value.trim().toLowerCase();
      };

      const filterFriendsByQuery = (query) =>
        friendsState.items.filter((friend) => {
          if (!friend) {
            return false;
          }
          if (!query) {
            return true;
          }
          const name = String(friend.name || "").toLowerCase();
          const username = String(friend.username || "").toLowerCase();
          return name.includes(query) || username.includes(query);
        });

      const resetFriendScheduleState = () => {
        friendsPageState.selectedUsername = "";
        friendsPageState.name = "";
        friendsPageState.schedule = createEmptySchedule();
        friendsPageState.classes = [];
        friendsPageState.loaded = false;
        friendsPageState.loading = false;
        friendsPageState.error = "";
      };

      const renderFriendSchedule = () => {
        if (!elements.friendScheduleGrid) {
          return;
        }
        const dayFilter = elements.friendScheduleDay ? elements.friendScheduleDay.value : "all";
        friendsPageState.dayFilter = dayFilter;
        elements.friendScheduleGrid.innerHTML = "";
        if (elements.friendScheduleDay) {
          elements.friendScheduleDay.disabled = !friendsPageState.selectedUsername;
        }

        if (!friendsPageState.selectedUsername) {
          renderStudyEmpty(elements.friendScheduleGrid, "Select a friend to view their schedule.");
          if (elements.friendScheduleTitle) {
            elements.friendScheduleTitle.textContent = "Friend schedule";
          }
          if (elements.friendScheduleSubtitle) {
            elements.friendScheduleSubtitle.textContent = "Select a friend to view their week.";
          }
          return;
        }

        if (friendsPageState.loading) {
          renderStudyEmpty(elements.friendScheduleGrid, "Loading schedule...");
          if (elements.friendScheduleTitle) {
            elements.friendScheduleTitle.textContent = `Schedule for ${friendsPageState.name || "friend"}`;
          }
          if (elements.friendScheduleSubtitle) {
            elements.friendScheduleSubtitle.textContent = "Fetching the latest schedule.";
          }
          return;
        }

        if (friendsPageState.error) {
          renderStudyEmpty(elements.friendScheduleGrid, friendsPageState.error);
          if (elements.friendScheduleTitle) {
            elements.friendScheduleTitle.textContent = `Schedule for ${friendsPageState.name || "friend"}`;
          }
          if (elements.friendScheduleSubtitle) {
            elements.friendScheduleSubtitle.textContent = "Schedule unavailable.";
          }
          return;
        }

        const schedule = friendsPageState.schedule || createEmptySchedule();
        const daysToShow =
          dayFilter === "all" ? dayOrder : dayOrder.includes(dayFilter) ? [dayFilter] : dayOrder;
        const hasEntries = daysToShow.some((day) => (schedule[day] || []).length);

        if (elements.friendScheduleTitle) {
          elements.friendScheduleTitle.textContent = `Schedule for ${friendsPageState.name || "friend"}`;
        }
        if (elements.friendScheduleSubtitle) {
          elements.friendScheduleSubtitle.textContent = hasEntries
            ? "Shared schedule details."
            : "No classes shared yet.";
        }

        daysToShow.forEach((day) => {
          const dayCard = document.createElement("div");
          dayCard.className = "schedule-day";
          const header = document.createElement("h4");
          header.textContent = day;
          dayCard.appendChild(header);

          const entries = [...(schedule[day] || [])].sort(
            (a, b) => parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start)
          );
          if (!entries.length) {
            const empty = document.createElement("div");
            empty.className = "muted";
            empty.textContent = "No classes";
            dayCard.appendChild(empty);
          } else {
            entries.forEach((entry) => {
              const entryType = entry.type || "class";
              const classInfo = entryType === "class" ? getFriendScheduleClassById(entry.classId) : null;
              const button = document.createElement("button");
              button.type = "button";
              button.className = "class-item";
              const accentColor =
                entryType === "class" && classInfo
                  ? classInfo.color
                  : scheduleTypeColors[entry.scheduleType] || "#4ac8ff";
              button.style.setProperty("--accent-color", accentColor);
              const title = entryType === "class" ? (classInfo ? classInfo.name : "Class") : entry.title || "Event";
              const periodLabel =
                entryType === "class" && entry.period ? ` · Period ${entry.period}` : entryType === "class" ? "" : "";
              button.innerHTML = `
                <div>${title}</div>
                <small>${formatTimeRange(entry.start, entry.end)}${entryType === "class" ? periodLabel : " · Event"}</small>
              `;
              dayCard.appendChild(button);
            });
          }

          elements.friendScheduleGrid.appendChild(dayCard);
        });
      };

      const selectFriendForSchedule = async (username, label) => {
        if (!username) {
          resetFriendScheduleState();
          renderFriendSchedule();
          renderFriends();
          return;
        }
        if (friendsPageState.selectedUsername === username && friendsPageState.loaded) {
          friendsPageState.name = label || friendsPageState.name;
          friendsPageState.error = "";
          renderFriendSchedule();
          renderFriends();
          return;
        }
        friendsPageState.selectedUsername = username;
        friendsPageState.name = label || username;
        friendsPageState.schedule = createEmptySchedule();
        friendsPageState.classes = [];
        friendsPageState.loaded = false;
        friendsPageState.loading = true;
        friendsPageState.error = "";
        renderFriendSchedule();
        renderFriends();

        const data = await loadClassmateSchedule(username);
        friendsPageState.loading = false;
        if (!data) {
          friendsPageState.loaded = true;
          friendsPageState.error = "Schedule not shared or unavailable.";
          renderFriendSchedule();
          renderFriends();
          return;
        }
        friendsPageState.schedule = data.schedule || createEmptySchedule();
        friendsPageState.classes = data.classes || [];
        friendsPageState.loaded = true;
        friendsPageState.error = "";
        renderFriendSchedule();
        renderFriends();
      };

      const syncFriendsScheduleSelection = async () => {
        if (!elements.friendScheduleGrid) {
          return;
        }
        const options = getFriendOptions();
        if (!options.length) {
          resetFriendScheduleState();
          renderFriendSchedule();
          return;
        }
        const selected =
          options.find(
            (option) =>
              option.username.toLowerCase() === String(friendsPageState.selectedUsername || "").toLowerCase()
          ) || options[0];
        await selectFriendForSchedule(selected.username, selected.label);
      };

      const renderFriends = () => {
        if (!elements.friendList) {
          return;
        }
        elements.friendList.innerHTML = "";
        const query = getFriendSearchQuery();
        friendsPageState.search = query;
        const filtered = filterFriendsByQuery(query);
        if (!filtered.length) {
          renderStudyEmpty(
            elements.friendList,
            query ? "No friends match that search." : "No friends yet. Add one to start chatting."
          );
          return;
        }
        filtered.forEach((friend) => {
          const item = document.createElement("div");
          const username = friend.username || friend.name || "";
          item.className = `friend-item${friendsPageState.selectedUsername === username ? " active" : ""}`;
          const displayName = friend.name || friend.username || "Unknown";
          const name = document.createElement("a");
          name.href = `/u/${encodeURIComponent(username)}`;
          name.className = "link-button";
          name.textContent = displayName;
          const actions = document.createElement("div");
          actions.className = "friend-item-actions";
          const viewButton = document.createElement("button");
          viewButton.type = "button";
          viewButton.textContent = friendsPageState.selectedUsername === username ? "Viewing" : "View";
          viewButton.disabled = friendsPageState.selectedUsername === username;
          viewButton.addEventListener("click", () => selectFriendForSchedule(username, displayName));
          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.textContent = "Remove";
          removeButton.addEventListener("click", () => removeFriend(friend.id));
          item.appendChild(name);
          actions.appendChild(viewButton);
          actions.appendChild(removeButton);
          item.appendChild(actions);
          elements.friendList.appendChild(item);
        });
      };

      const renderFriendRequests = () => {
        if (!elements.friendRequestsIncoming || !elements.friendRequestsOutgoing) {
          return;
        }
        elements.friendRequestsIncoming.innerHTML = "";
        elements.friendRequestsOutgoing.innerHTML = "";

        if (!friendRequestsState.incoming.length) {
          renderStudyEmpty(elements.friendRequestsIncoming, "No incoming requests.");
        } else {
          friendRequestsState.incoming.forEach((request) => {
            const item = document.createElement("div");
            item.className = "friend-item";
            const name = document.createElement("a");
            const fromUser = request.from || "";
            name.href = `/u/${encodeURIComponent(fromUser)}`;
            name.className = "link-button";
            name.textContent = fromUser || "Unknown";
            const actions = document.createElement("div");
            actions.className = "friend-item-actions";
            const acceptButton = document.createElement("button");
            acceptButton.type = "button";
            acceptButton.textContent = "Accept";
            acceptButton.addEventListener("click", () => acceptFriendRequest(request.id));
            const declineButton = document.createElement("button");
            declineButton.type = "button";
            declineButton.textContent = "Decline";
            declineButton.addEventListener("click", () => declineFriendRequest(request.id));
            actions.appendChild(acceptButton);
            actions.appendChild(declineButton);
            item.appendChild(name);
            item.appendChild(actions);
            elements.friendRequestsIncoming.appendChild(item);
          });
        }

        if (!friendRequestsState.outgoing.length) {
          renderStudyEmpty(elements.friendRequestsOutgoing, "No outgoing requests.");
        } else {
          friendRequestsState.outgoing.forEach((request) => {
            const item = document.createElement("div");
            item.className = "friend-item";
            const name = document.createElement("a");
            const toUser = request.to || "";
            name.href = `/u/${encodeURIComponent(toUser)}`;
            name.className = "link-button";
            name.textContent = toUser || "Unknown";
            const actions = document.createElement("div");
            actions.className = "friend-item-actions";
            const cancelButton = document.createElement("button");
            cancelButton.type = "button";
            cancelButton.textContent = "Cancel";
            cancelButton.addEventListener("click", () => cancelFriendRequest(request.id));
            actions.appendChild(cancelButton);
            item.appendChild(name);
            item.appendChild(actions);
            elements.friendRequestsOutgoing.appendChild(item);
          });
        }
      };

      const loadFriends = async () => {
        try {
          const response = await fetch("/api/friends");
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Friends load failed");
          }
          const data = await response.json();
          friendsState.items = Array.isArray(data.friends) ? data.friends : [];
        } catch (error) {
          friendsState.items = [];
        }
        await syncClassmateSelection();
        renderFriends();
        await syncFriendsScheduleSelection();
        renderChatList();
        renderChatThread();
      };

      const loadFriendRequests = async () => {
        try {
          const response = await fetch("/api/friend-requests");
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Requests load failed");
          }
          const data = await response.json();
          friendRequestsState.incoming = Array.isArray(data.incoming) ? data.incoming : [];
          friendRequestsState.outgoing = Array.isArray(data.outgoing) ? data.outgoing : [];
        } catch (error) {
          friendRequestsState.incoming = [];
          friendRequestsState.outgoing = [];
        }
        renderFriendRequests();
      };

      const addFriend = async (event) => {
        event.preventDefault();
        const name = elements.friendName.value.trim();
        if (!name) {
          return;
        }
        try {
          const response = await fetch("/api/friend-requests", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            if (data.error) {
              window.alert(data.error);
            }
            throw new Error("Friend add failed");
          }
          elements.friendForm.reset();
          await loadFriendRequests();
        } catch (error) {
          renderFriendRequests();
        }
      };

      const acceptFriendRequest = async (id) => {
        if (!id) {
          return;
        }
        try {
          const response = await fetch("/api/friend-requests/accept", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Request accept failed");
          }
          await loadFriends();
          await loadFriendRequests();
        } catch (error) {
          renderFriendRequests();
        }
      };

      const declineFriendRequest = async (id) => {
        if (!id) {
          return;
        }
        try {
          const response = await fetch("/api/friend-requests/decline", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Request decline failed");
          }
          await loadFriendRequests();
        } catch (error) {
          renderFriendRequests();
        }
      };

      const cancelFriendRequest = async (id) => {
        if (!id) {
          return;
        }
        try {
          const response = await fetch("/api/friend-requests/cancel", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Request cancel failed");
          }
          await loadFriendRequests();
        } catch (error) {
          renderFriendRequests();
        }
      };

      const loadGroups = async () => {
        try {
          const response = await fetch("/api/groups");
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Group load failed");
          }
          const data = await response.json();
          groupsState.items = Array.isArray(data.groups) ? data.groups : [];
        } catch (error) {
          groupsState.items = [];
        }
        renderChatList();
        renderChatThread();
      };

      const addGroup = async (event) => {
        event.preventDefault();
        if (!elements.groupName || !elements.groupMembers) {
          return;
        }
        const name = elements.groupName.value.trim();
        const membersInput = elements.groupMembers.value.trim();
        if (!name) {
          return;
        }
        const members = membersInput
          ? membersInput
              .split(",")
              .map((item) => item.trim())
              .filter(Boolean)
          : [];
        try {
          const response = await fetch("/api/groups", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, members }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            if (data.error) {
              window.alert(data.error);
            }
            throw new Error("Group add failed");
          }
          if (data.group) {
            groupsState.items.push(data.group);
            state.chatMode = "groups";
            state.chatTarget = { type: "group", id: data.group.id };
          } else {
            await loadGroups();
          }
          if (elements.groupForm) {
            elements.groupForm.reset();
          }
          renderChatList();
          renderChatThread();
        } catch (error) {
          renderChatList();
          renderChatThread();
        }
      };

      const handleProfileAvatarChange = (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const result = typeof reader.result === "string" ? reader.result : "";
          profileState.avatar = result;
          applyProfileForm();
          applyDemoProfile();
        };
        reader.readAsDataURL(file);
      };

      const initProfile = () => {
        if (!elements.profileForm) {
          return;
        }
        elements.profileForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          profileState.bio = elements.profileBioInput ? elements.profileBioInput.value.trim() : "";
          const saved = await saveProfile();
          if (saved) {
            applyProfileForm();
            applyDemoProfile();
          }
        });
        if (elements.profileAvatarInput) {
          elements.profileAvatarInput.addEventListener("change", handleProfileAvatarChange);
        }
      };

      const removeFriend = async (id) => {
        try {
          const removedFriend = friendsState.items.find((friend) => friend.id === id);
          const response = await fetch("/api/friends/remove", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          if (!response.ok) {
            throw new Error("Friend remove failed");
          }
          friendsState.items = friendsState.items.filter((friend) => friend.id !== id);
          const removedUsername = removedFriend ? removedFriend.username || removedFriend.name || "" : "";
          if (removedUsername && removedUsername === friendsPageState.selectedUsername) {
            resetFriendScheduleState();
            renderFriendSchedule();
          }
          await syncClassmateSelection();
          renderFriends();
          await syncFriendsScheduleSelection();
          renderChatList();
          renderChatThread();
        } catch (error) {
          renderFriends();
        }
      };

      const initNavigation = () => {
        const handleNav = (event) => {
          const target = event.currentTarget.getAttribute("data-page-target");
          setPage(target);
        };
        document.querySelectorAll("[data-page-target]").forEach((button) => {
          button.addEventListener("click", handleNav);
          button.addEventListener(
            "touchend",
            (event) => {
              event.preventDefault();
              handleNav(event);
            },
            { passive: false }
          );
        });
      };

      const initSchedule = () => {
        elements.scheduleToggle.querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", () => {
            setScheduleView(button.dataset.scheduleView);
          });
        });
        if (elements.classmateSelect) {
          elements.classmateSelect.addEventListener("change", () => {
            const username = elements.classmateSelect.value;
            const label = elements.classmateSelect.selectedOptions[0]?.textContent || "";
            selectClassmate(username, label);
          });
        }
        elements.scheduleForm.addEventListener("submit", addScheduleItem);
      };

      const initChat = () => {
        if (elements.chatModeToggle) {
          elements.chatModeToggle.querySelectorAll("button").forEach((button) => {
            button.addEventListener("click", () => {
              setChatMode(button.dataset.chatMode);
            });
          });
        }
        if (elements.groupForm) {
          elements.groupForm.addEventListener("submit", addGroup);
        }
        if (elements.chatNewGroup) {
          elements.chatNewGroup.addEventListener("click", () => {
            setChatMode("groups");
            if (elements.groupName) {
              elements.groupName.focus();
            }
          });
        }
        elements.chatForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const value = elements.chatInput.value.trim();
          const target = state.chatTarget;
          if (!value || !target) {
            return;
          }
          const result = await postChatMessage(target, value);
          if (result && result.message) {
            ensureChatThread(result.threadId).push(result.message);
          }
          elements.chatInput.value = "";
          renderChatList();
          renderChatThread();
        });
      };

      const initTodos = () => {
        elements.todoForm.addEventListener("submit", addTodo);
        [elements.filterClass, elements.filterStatus, elements.filterDue].forEach((select) => {
          select.addEventListener("change", renderTodoList);
        });
      };

      const initFriends = () => {
        if (!elements.friendForm) {
          return;
        }
        elements.friendForm.addEventListener("submit", addFriend);
        if (elements.friendSearch) {
          elements.friendSearch.addEventListener("input", renderFriends);
        }
        if (elements.friendScheduleDay) {
          elements.friendScheduleDay.addEventListener("change", renderFriendSchedule);
        }
      };

      const setFeedbackOpen = (open) => {
        if (!elements.feedbackWidget || !elements.feedbackToggle || !elements.feedbackPanel) {
          return;
        }
        elements.feedbackWidget.classList.toggle("open", open);
        elements.feedbackToggle.setAttribute("aria-expanded", String(open));
        elements.feedbackPanel.setAttribute("aria-hidden", String(!open));
        if (open && elements.feedbackInput) {
          elements.feedbackInput.focus();
        }
      };

      const setFeedbackStatus = (message, kind) => {
        if (!elements.feedbackStatus) {
          return;
        }
        elements.feedbackStatus.textContent = message || "";
        elements.feedbackStatus.classList.remove("error", "success");
        if (kind) {
          elements.feedbackStatus.classList.add(kind);
        }
      };

      const setFeedbackBusy = (busy) => {
        if (!elements.feedbackForm) {
          return;
        }
        elements.feedbackForm.querySelectorAll("button, textarea").forEach((field) => {
          field.disabled = busy;
        });
      };

      const sendFeedback = async () => {
        if (!elements.feedbackInput) {
          return;
        }
        const message = elements.feedbackInput.value.trim();
        if (!message) {
          setFeedbackStatus("Tell us what's wrong first.", "error");
          elements.feedbackInput.focus();
          return;
        }
        setFeedbackStatus("Sending...");
        setFeedbackBusy(true);
        try {
          const response = await fetch("/api/feedback", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ issue: message }),
          });
          if (response.status === 401) {
            window.location.href = "/signin";
            return;
          }
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            setFeedbackStatus(data.error || "Feedback failed.", "error");
            return;
          }
          elements.feedbackInput.value = "";
          setFeedbackStatus("Thanks! Your feedback was saved.", "success");
        } catch (error) {
          setFeedbackStatus("Network error. Try again.", "error");
        } finally {
          setFeedbackBusy(false);
        }
      };

      const initFeedback = () => {
        if (!elements.feedbackWidget || !elements.feedbackToggle || !elements.feedbackPanel) {
          return;
        }
        elements.feedbackToggle.addEventListener("click", (event) => {
          event.stopPropagation();
          const isOpen = elements.feedbackWidget.classList.contains("open");
          setFeedbackStatus("");
          setFeedbackOpen(!isOpen);
        });
        if (elements.feedbackCancel) {
          elements.feedbackCancel.addEventListener("click", () => {
            setFeedbackOpen(false);
          });
        }
        if (elements.feedbackPanel) {
          elements.feedbackPanel.addEventListener("click", (event) => {
            event.stopPropagation();
          });
        }
        document.addEventListener("click", () => {
          setFeedbackOpen(false);
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setFeedbackOpen(false);
          }
        });
        if (elements.feedbackForm) {
          elements.feedbackForm.addEventListener("submit", (event) => {
            event.preventDefault();
            sendFeedback();
          });
        }
      };

      const init = async () => {
        initNavigation();
        initSchedule();
        initScheduleSetup();
        initChat();
        initFriends();
        initProfile();
        initAuth();
        initFeedback();

        await loadUser();
        initStudySystem();
        initTodos();

        await loadSettings();
        applySettings();
        renderSettings();

        loadScheduleExtras();

        await loadProfile();
        const serverData = await loadServerData();
        if (shouldStartScheduleSetup(serverData)) {
          if (!Array.isArray(serverData.classes) || !serverData.classes.length) {
            mockData.classes = [];
          }
          mockData.schedules.my = buildEmptySchedule();
          openScheduleSetup();
        }
        loadTodos();
        await loadChats();
        await loadFriends();
        await loadFriendRequests();
        await loadGroups();
        applyDemoProfile();

        renderTodoSelectors();
        renderTodoList();

        renderSchedule();
        renderChatList();
        renderChatThread();

        setInterval(() => updateCountdown(buildScheduleMap()), 1000);
      };

      init();
    </script>
  </body>
</html>
